---
title: Make recurring payments
---

import { LinkOut } from '@interledger/docs-design-system'
import { Tabs, TabItem, Badge } from '@astrojs/starlight/components'
import StartInteraction from '/src/partials/grant-start-interaction.mdx'
import FinishInteraction from '/src/partials/grant-finish-interaction.mdx'

:::tip[Summary]
Learn how an Open Payments-enabled client can be used to set up a payment of a specific amount that pays out at a recurring interval.
:::

The Open Payments APIs facilitate multiple use cases for recurring payments to and from Open Payments-enabled wallets. Paying a fee for a monthly subscription service is one example.

This guide provides the steps your Open Payments-enabled client will take to set up a $50 USD payment from a user that recurs once a month for three months. There's a few different ways to set up the payment. In this guide, you'll begin by getting an outgoing payment grant, then request the creation of an incoming payment resource and an outgoing payment resource at each interval.

## Endpoints

- <Badge text="GET" variant="note" /> <LinkOut href='https://openpayments.dev/apis/wallet-address-server/operations/get-wallet-address/'>Get Wallet Address</LinkOut>
- <Badge text="POST" variant="success" /> <LinkOut href='https://openpayments.dev/apis/auth-server/operations/post-request/'>Grant Request</LinkOut>
- <Badge text="POST" variant="success" /> <LinkOut href='https://openpayments.dev/apis/resource-server/operations/create-incoming-payment/'>Create an Incoming Payment</LinkOut>
- <Badge text="POST" variant="success" /> <LinkOut href='https://openpayments.dev/apis/resource-server/operations/create-outgoing-payment/'>Create an Outgoing Payment</LinkOut>
- <Badge text="POST" variant="success" /> <LinkOut href='https://openpayments.dev/apis/auth-server/operations/post-token/'>Rotate an Access Token</LinkOut>

## Steps

### 1. Get wallet address information

To set up a recurring payment, the client must get the wallet address information for both the sender and recipient.

Let's assume the sender's wallet address is already saved in your client. The sender is essentially your client's user. Let's also assume the sender has entered the recipient's wallet address into a payment form in your client application.

Call the <Badge text="GET" variant="note" /> [Get Wallet Address API](/apis/wallet-address-server/operations/get-wallet-address) for each address.

<Tabs syncKey="lang">
<TabItem label='TypeScript/JavaScript' icon='seti:javascript'>
  ```ts
  const senderWalletAddress = await client.walletAddress.get({
    url: 'https://cloudninebank.example.com/sender'
  })
  const recipientWalletAddress = await client.walletAddress.get({
    url: 'https://happylifebank.example.com/recipient'
  })
  ```
 </TabItem>
 <TabItem label='Rust' icon='seti:rust'>
 ```rust
 let sender_wallet_address = client.wallet_address().get("https://cloudninebank.example.com/sender").await?;
 let recipient_wallet_address = client.wallet_address().get("https://happylifebank.example.com/recipient").await?;
 ```
 </TabItem>
</Tabs>

<details>
  <summary>Example response</summary>
  The following shows an example response from the recipient's wallet provider. A similar response will be returned from the sender's wallet provider.
  ```json wrap
  {
    "id": "https://happylifebank.example.com/recipient",
    "assetCode": "USD",
    "assetScale": 2,
    "authServer": "https://auth.happylifebank.example.com/",
    "resourceServer": "https://happylifebank.example.com/op"
  }
  ```
</details>

### 2. Request an interactive outgoing payment grant

Use the sender wallet's `authServer` information received in the previous step to call the <Badge text="POST" variant="success" /> [Grant Request API](/apis/auth-server/operations/post-request).

This call obtains an access token that allows your client to request outgoing payment resources be created on the sender's wallet account.

:::note
Outgoing payments require an interactive grant. This type of grant will obtain the user's consent before an outgoing payment is made against their wallet account. You can find more information in the [Open Payments flow](/concepts/op-flow/#outgoing-payment) and [identity providers](/identity/idp) pages.
:::

Include the following in the request:

- `limits` object
  - `debitAmount` - The maximum amount that the user will pay per interval (for example, per month). When the next interval begins, the value resets.
  - `interval` - The [time interval](#about-the-interval) under which the grant is valid.

Remember that your user, the sender, wants to make payments of $50 a month for three months. The amount resets each month and any unspent portions don't roll over.

<Tabs syncKey="lang">
<TabItem label='TypeScript/JavaScript' icon='seti:javascript'>
  ```ts wrap
  const pendingSenderOutgoingPaymentGrant = await client.grant.request(
    {
      url: senderWalletAddress.authServer,
    },
    {
      access_token: {
        access: [
          {
            identifier: senderWalletAddress.id,
            type: 'outgoing-payment',
            actions: ['read', 'create'],
            limits: {
              interval: 'R3/2025-03-12T23:25:00Z/P1M',
              debitAmount: {
                assetCode: 'USD',
                assetScale: 2,
                value: '5000',
              },
            },
          },
        ],
      },
      interact: {
        start: ['redirect'],
        finish: {
          method: 'redirect',
          uri: 'https://paymentplatform.example/finish/{...}', // where to redirect the user after they've completed the interaction
          nonce: NONCE,
        },
      },
    },
  );
  ```
 </TabItem>
 <TabItem label='Rust' icon='seti:rust'>
 ```rust
 use open_payments::types::{AccessTokenRequest, AccessItem, OutgoingPaymentAction, AccessLimits, Amount, InteractRequest, InteractStart, InteractFinish, InteractFinishMethod, GrantRequest};
 let outgoing_access = AccessTokenRequest {
   access: vec![AccessItem::OutgoingPayment {
     identifier: Some(sender_wallet_address.id.clone()),
     actions: vec![OutgoingPaymentAction::Create, OutgoingPaymentAction::Read],
     limits: Some(AccessLimits {
       interval: Some("R3/2025-03-12T23:25:00Z/P1M".into()),
       debit_amount: Some(Amount { value: "5000".into(), asset_code: "USD".into(), asset_scale: 2 }),
       ..Default::default()
     }),
   }],
 };
 let interact = InteractRequest { start: Some(vec![InteractStart::Redirect]), finish: Some(InteractFinish { method: InteractFinishMethod::Redirect, uri: Some("https://paymentplatform.example/finish/{...}".into()), nonce: Some("NONCE".into()) }) };
 let outgoing_grant_request = GrantRequest::new(outgoing_access, Some(interact));
 let pending_sender_outgoing_payment_grant = client
   .grant()
   .request(&sender_wallet_address.auth_server, &outgoing_grant_request)
   .await?;
 ```
 </TabItem>
</Tabs>

<details>
  <summary>Example response</summary>
  ```json wrap
  {
    "interact": {
      "redirect": "https://auth.interledger-test.dev/{...}", // uri to redirect the user to, to begin interaction
      "finish": "..." // unique key to secure the callback
    },
    "continue": {
      "access_token": {
        "value": "..." // access token for continuing the outgoing payment grant request
      },
      "uri": "https://auth.interledger-test.dev/continue/{...}", // uri for continuing the outgoing payment grant request
      "wait": 30
    }
  }
  ```
</details>

#### About the interval

The interval used in this guide is `R3/2025-03-12T23:25:00Z/P1M`. Remember that your user wants to send payments of $50 USD a month for three months. The interval breaks down like this:

- `R3/` is the number of repetitions - three
- `2025-03-12` is the start date of the repeating interval - 12 March 2025
- `T23:25:00Z/` is the start time of the repeating interval - 11:25 PM UTC
- `P1M` is the period between each interval - one month. Used with `R3`, you have a grant that's valid once a month for three months.

Altogether, this grant will allow your user to send $50 USD three times, from:

- 11:25 PM UTC on 12 March 2025 through 11:24 PM UTC on 12 April 2025
- 11:25 PM UTC on 12 April 2025 through 11:24 PM UTC on 12 May 2025
- 11:25 PM UTC on 12 May 2025 through 11:24 PM UTC on 12 June 2025

### 3. Start interaction with the user

<StartInteraction />

### 4. Finish interaction with the user

<FinishInteraction />

### 5. Request a grant continuation

In this guide, we're assuming the IdP the user interacted with has a user interface. When the interaction completes, the user is returned to your client. Now your client can make a continuation request for the outgoing payment grant.

:::note
In a scenario where a user interface isn't available, consider implementing a polling mechanism in the client to check for the completion of the interaction.
:::

Call the <Badge text="POST" variant="success" /> [Grant Continuation Request API](/apis/auth-server/operations/post-continue). This call obtains an access token that allows your client to continue the outgoing payment request.

Issue the request to the `continue.uri` provided in the initial outgoing payment grant response (Step 2).

Include the `interact_ref` returned in the redirect URI's query parameters.

<Tabs syncKey="lang">
<TabItem label='TypeScript/JavaScript' icon='seti:javascript'>
  ```ts wrap
  const senderOutgoingPaymentGrant = await client.grant.continue(
    {
      url: pendingSenderOutgoingPaymentGrant.continue.uri,
      accessToken: pendingSenderOutgoingPaymentGrant.continue.access_token.value
    },
    {
      interact_ref: interactRef
    }
  )
  ```
 </TabItem>
 <TabItem label='Rust' icon='seti:rust'>
 ```rust
 let continue_field = match &pending_sender_outgoing_payment_grant.continue_field {
   Some(c) => c,
   None => {
     eprintln!("Missing continue field on pending grant");
     return Ok(());
   }
 };
 let sender_outgoing_payment_grant = client
   .grant()
   .continue_grant(
     &continue_field.uri,
     &interact_ref,
     Some(&continue_field.access_token.value),
   )
   .await?;
 ```
 </TabItem>
</Tabs>

<details>
  <summary>Example response</summary>
  ```json wrap
  {
    "access_token": {
      "value": "...", // final access token required before creating an outgoing payment
      "manage": "https://auth.cloudninebank.example.com/token/{...}", // management uri for access token
      "access": [
        {
          "type": "outgoing-payment",
          "actions": ["create", "read"],
          "identifier": "https://cloudninebank.example.com/sender",
          "limits:" {
            "interval": "R3/2025-03-12T23:25:00Z/P1M"
            "debitAmount": {
              "assetCode": "USD",
              "assetScale": 2,
              "value": "5000",
            }
          }
        }
      ]
    },
    "continue": {
      "access_token": {
        "value": "..." // access token for continuing the request
      },
      "uri": "https://auth.cloudninebank.example.com/continue/{...}" // continuation request uri
    }
  }
  ```
</details>

### 6. Request an incoming payment grant

Use the recipient's `authServer` details, returned in Step 1, to call the <Badge text="POST" variant="success" /> [Grant Request API](/apis/auth-server/operations/post-request).

This call obtains an access token that allows your client to request an incoming payment resource be created on the recipient's wallet account.

<Tabs syncKey="lang">
<TabItem label='TypeScript/JavaScript' icon='seti:javascript'>
  ```ts
  const recipientIncomingPaymentGrant = await client.grant.request(
    {
      url: recipientWalletAddress.authServer
    },
    {
      access_token: {
        access: [
          {
            type: "incoming-payment",
            actions: ["read", "create"],
          },
        ],
      },
    },
  );
  ```
 </TabItem>
 <TabItem label='Rust' icon='seti:rust'>
 ```rust
 use open_payments::types::{AccessTokenRequest, AccessItem, IncomingPaymentAction, GrantRequest};
 let incoming_access = AccessTokenRequest {
   access: vec![AccessItem::IncomingPayment { actions: vec![IncomingPaymentAction::Create, IncomingPaymentAction::Read], identifier: None }],
 };
 let incoming_grant_request = GrantRequest::new(incoming_access, None);
 let recipient_incoming_payment_grant = client
   .grant()
   .request(&recipient_wallet_address.auth_server, &incoming_grant_request)
   .await?;
 ```
 </TabItem>
</Tabs>

<details>
  <summary>Example response</summary>
  ```json wrap
  {
    "access_token": {
      "value": "...", // access token value for incoming payment grant
      "manage": "https://auth.happylifebank.example.com/token/{...}", // management uri for access token
      "access": [
        {
          "type": "incoming-payment",
          "actions": ["create", "read"]
        }
      ]
    },
    "continue": {
      "access_token": {
        "value": "..." // access token for continuing the request
      },
      "uri": "https://auth.happylifebank.example.com/continue/{...}" // continuation request uri
    }
  }
  ```
</details>

### 7. Request the creation of an incoming payment resource

Use the access token returned in the previous response to call the <Badge text="POST" variant="success" /> [Create Incoming Payment API](/apis/resource-server/operations/create-incoming-payment).

This call requests an incoming payment resource be created on the recipient's wallet account.

The `value` is the maximum allowable amount that can be paid into this resource. Since the monthly payment is for $50 USD, the `value` is `5000`.

<Tabs syncKey="lang">
<TabItem label='TypeScript/JavaScript' icon='seti:javascript'>
  ```ts
  const recipientIncomingPayment = await client.incomingPayment.create(
    {
      url: recipientWalletAddress.resourceServer,
      accessToken: recipientIncomingPaymentGrant.access_token.value
    },
    {
      walletAddress: recipientWalletAddress.id,
      incomingAmount: {
        value: '5000',
        assetCode: 'USD',
        assetScale: 2
      },
    },
  )
  ```
 </TabItem>
 <TabItem label='Rust' icon='seti:rust'>
 ```rust
 use open_payments::types::{IncomingPaymentRequest, Amount};
 let incoming_request = IncomingPaymentRequest {
   wallet_address: recipient_wallet_address.id.clone(),
   incoming_amount: Some(Amount { value: "5000".into(), asset_code: "USD".into(), asset_scale: 2 }),
   expires_at: None,
   metadata: None,
 };
 let recipient_incoming_payment = client
   .incoming_payments()
   .create(
     &recipient_wallet_address.resource_server,
     &incoming_request,
     Some(&recipient_incoming_payment_grant.access_token.value),
   )
   .await?;
 ```
 </TabItem>
</Tabs>

<details>
  <summary>Example response</summary>
  ```json wrap
  {
    "id": "https://happylifebank.example.com/incoming-payments/{...}",
    "walletAddress": "https://happylifebank.example.com/recipient",
    "incomingAmount": {
      "value": "5000",
      "assetCode": "USD",
      "assetScale": 2
    },
    "receivedAmount": {
      "value": "0",
      "assetCode": "USD",
      "assetScale": 2
    },
    "completed": false,
    "createdAt": "2025-03-12T23:20:50.52Z",
    "methods": [
      {
        "type": "ilp",
        "ilpAddress": "...",
        "sharedSecret": "..."
      }
    ]
  }
  ```
</details>

### 8. Request the creation of an outgoing payment resource

Use the access token returned in the grant continuation response (Step 5) to call the <Badge text="POST" variant="success" /> [Create Outgoing Payment API](/apis/resource-server/operations/create-outgoing-payment).

<Tabs syncKey="lang">
<TabItem label='TypeScript/JavaScript' icon='seti:javascript'>
  ```ts
  const senderOutgoingPaymentToRecipient = await client.outgoingPayment.create(
    {
      url: senderWalletAddress.resourceServer,
      accessToken: senderOutgoingPaymentGrant.access_token.value
    },
    {
      walletAddress: senderWalletAddress.id,
      incomingPayment: 'https://happylifebank.example/com/incoming-payments/{...}',
    },
  )
  ```
 </TabItem>
 <TabItem label='Rust' icon='seti:rust'>
 ```rust
 use open_payments::types::OutgoingPaymentRequest;
 let outgoing_request = OutgoingPaymentRequest {
   wallet_address: sender_wallet_address.id.clone(),
   receiver: Some(recipient_incoming_payment.id.clone()),
   debit_amount: None,
   receive_amount: None,
   quote_id: None,
 };
 let sender_outgoing_payment_to_recipient = client
   .outgoing_payments()
   .create(
     &sender_wallet_address.resource_server,
     &outgoing_request,
     Some(&sender_outgoing_payment_grant.access_token.value),
   )
   .await?;
 ```
 </TabItem>
</Tabs>

<details>
  <summary>Example response</summary>
  ```json wrap
  {
    "id": "https://cloudninebank.example.com/outgoing-payments/{...}", // url identifying the outgoing payment
    "walletAddress": "https://cloudninebank.example.com/sender",
    "receiver": "https://happylifebank.example.com/incoming-payments/{...}", // url of the incoming payment being paid
    "debitAmount": {
      "value": "5000",
      "assetCode": "USD",
      "assetScale": 2
    },
    "receiveAmount": {
      "value": "5000",
      "assetCode": "USD",
      "assetScale": 2
    },
    "sentAmount": {
      "value": "0",
      "assetCode": "USD",
      "assetScale": 2
    },
    "createdAt": "2025-03-12T23:27:54.52Z"
  }
  ```
</details>

The first of the three recurring payments is now set up. At the next interval (for example, one month from now), repeat Steps 6 - 8. You don't need to request new outgoing or incoming payment grants because the original grants are still valid.

:::note[Access token expiry]
If a particular grant's access token has expired, call the <Badge text="POST" variant="success" /> [Rotate Access Token API](/apis/auth-server/operations/post-token), then use the new token in the appropriate incoming or outgoing payment request.
:::

---
title: Split an incoming payment
---

import { LinkOut } from '@interledger/docs-design-system'
import { Tabs, TabItem, Badge } from '@astrojs/starlight/components'
import InteractionReq from '/src/partials/interaction-required.mdx'
import StartInteraction from '/src/partials/grant-start-interaction.mdx'
import FinishInteraction from '/src/partials/grant-finish-interaction.mdx'

:::tip[Summary]
Learn how to take a single payment and split the value between multiple recipients.
:::

Imagine making a purchase from an online marketplace. From your perspective, you're sending a single payment to a merchant in exchange for a good. Behind the scenes, the marketplace receives a portion of the payment as a service fee.

There's a few ways for the marketplace to collect their fee. For example, it could receive the full amount, deduct the fee, then send the rest to the merchant. However, holding funds for the merchant, even for a second, requires compliance with certain financial rules and regulations. A better way is to ensure both parties only receive the amount they're supposed to receive, directly from the user.

Remember, Open Payments doesn't execute payments or touch money in any way. It's used to issue payment instructions before any money movement occurs. An example of a payment instruction is, "of the \$6 purchase, pay the marketplace \$1 and the merchant $5." This way, funds meant for one party never pass through the other party.

## Scenario

For this guide, you'll assume the role of a platform operator of an online marketplace. The guide explains how to split a customer's $100 USD payment into two incoming payments. The merchant will receive 99% of the payment while you keep 1% as a fee.

The three parties involved in the transaction are the:

- Customer: the purchaser of a good or service on the marketplace
- Merchant: the seller of a good or service on the marketplace
- Platform operator: you, as the operator of the marketplace

## Endpoints

- <Badge text="GET" variant="note" />
  <LinkOut href="https://openpayments.dev/apis/wallet-address-server/operations/get-wallet-address/">
    Get Wallet Address
  </LinkOut>
- <Badge text="POST" variant="success" />
  <LinkOut href="https://openpayments.dev/apis/auth-server/operations/post-request/">
    Grant Request
  </LinkOut>
- <Badge text="POST" variant="success" />
  <LinkOut href="https://openpayments.dev/apis/resource-server/operations/create-incoming-payment/">
    Create Incoming Payment
  </LinkOut>
- <Badge text="POST" variant="success" />
  <LinkOut href="https://openpayments.dev/apis/resource-server/operations/create-quote/">
    Create a Quote
  </LinkOut>
- <Badge text="POST" variant="success" />
  <LinkOut href="https://openpayments.dev/apis/resource-server/operations/create-outgoing-payment/">
    Create an Outgoing Payment
  </LinkOut>

## Steps

### 1. Get wallet address information

When a customer initiates a payment, your platform must get wallet address information for the customer, the merchant, and you, as the operator.

Let's assume your wallet address is already saved to your platform, as is the merchant's. Let's also assume the customer provided their wallet address at the beginning of the checkout flow.

Call the <Badge text="GET" variant="note" /> [Get Wallet Address API](/apis/wallet-address-server/operations/get-wallet-address) for each address.

<Tabs syncKey="lang">
<TabItem label='TypeScript/JavaScript' icon='seti:javascript'>
  ```ts
  const customerWalletAddress = await client.walletAddress.get({
    url: 'https://cloudninebank.example.com/customer'
  })
  const merchantWalletAddress = await client.walletAddress.get({
    url: 'https://happylifebank.example.com/merchant'
  })
  const platformWalletAddress = await client.walletAddress.get({
    url: 'https://coolwallet.example.com/platform'
  })
```
 </TabItem>
 <TabItem label='Rust' icon='seti:rust'>
 ```rust wrap
 let customer_wallet_address = client.wallet_address().get("https://cloudninebank.example.com/customer").await?;
 let merchant_wallet_address = client.wallet_address().get("https://happylifebank.example.com/merchant").await?;
 let platform_wallet_address = client.wallet_address().get("https://coolwallet.example.com/platform").await?;
 ```
 </TabItem>
  <TabItem label='Go' icon='seti:go'>
  
  ```go wrap
  customerWalletAddress, err := client.WalletAddress.Get(context.TODO(), op.WalletAddressGetParams{
    URL: "https://cloudninebank.example.com/customer",
  })
  if err != nil {
    log.Fatalf("Error fetching customer wallet address: %v\n", err)
  }

  merchantWalletAddress, err := client.WalletAddress.Get(context.TODO(), op.WalletAddressGetParams{
    URL: "https://happylifebank.example.com/merchant",
  })
  if err != nil {
    log.Fatalf("Error fetching merchant wallet address: %v\n", err)
  }

  platformWalletAddress, err := client.WalletAddress.Get(context.TODO(), op.WalletAddressGetParams{
    URL: "https://coolwallet.example.com/platform",
  })
  if err != nil {
    log.Fatalf("Error fetching platform wallet address: %v\n", err)
  }
  ```
  </TabItem>
</Tabs>

<details>
<summary>Example response</summary>
The following shows an example response from the customer's wallet provider. Similar responses will be returned from the merchant's and platform's wallet provider.
```json wrap
{
  "id": "https://cloudninebank.example.com/customer",
  "assetCode": "USD",
  "assetScale": 2,
  "authServer": "https://auth.cloudninebank.example.com/",
  "resourceServer": "https://cloudninebank.example.com/op"
}
```
</details>

### 2. Request incoming payment grants

Use the merchant and platform `authServer` details, received in the previous step, to call the <Badge text="POST" variant="success" /> [Grant Request API](/apis/auth-server/operations/post-request).

These calls obtain access tokens that allow your platform to request an incoming payment resource be created on the merchant's wallet account and your wallet account.

:::note[Alternate scenario]
If you and the merchant use the same account servicing entity, and as a result, the same authorization server, you only need one `incomingPayment` grant.
:::

<Tabs syncKey="lang">
<TabItem label='TypeScript/JavaScript' icon='seti:javascript'>
  ```ts wrap
  // Merchant
  const merchantIncomingPaymentGrant = await client.grant.request(
    {
      url: merchantWalletAddress.authServer
    },
    {
      access_token: {
        access: [
          {
            type: "incoming-payment",
            actions: ["create"],
          },
        ],
      },
    },
  );
  // Platform
  const platformIncomingPaymentGrant = await client.grant.request(
    {
      url: platformWalletAddress.authServer
    },
    {
      access_token: {
        access: [
          {
            type: "incoming-payment",
            actions: ["create"],
          },
        ],
      },
    },
  );
````
 </TabItem>
 <TabItem label='Rust' icon='seti:rust'>
 ```rust wrap
 use open_payments::types::{AccessTokenRequest, AccessItem, IncomingPaymentAction, GrantRequest};
 let incoming_access = AccessTokenRequest {
   access: vec![AccessItem::IncomingPayment { actions: vec![IncomingPaymentAction::Create], identifier: None }],
 };
 let merchant_grant_request = GrantRequest::new(incoming_access.clone(), None);
 let platform_grant_request = GrantRequest::new(incoming_access, None);
 let merchant_incoming_payment_grant = client
   .grant()
   .request(&merchant_wallet_address.auth_server, &merchant_grant_request)
   .await?;
 let platform_incoming_payment_grant = client
   .grant()
   .request(&platform_wallet_address.auth_server, &platform_grant_request)
   .await?;
 ```
 </TabItem>

 <TabItem label='Go' icon='seti:go'>

  ```go wrap
  incomingAccess := as.AccessIncoming{
    Type:    as.IncomingPayment,
    Actions: []as.AccessIncomingActions{as.AccessIncomingActionsCreate},
  }
  accessItem := as.AccessItem{}
  if err := accessItem.FromAccessIncoming(incomingAccess); err != nil {
    log.Fatalf("Error creating AccessItem: %v\n", err)
  }
  accessToken := struct {
    Access as.Access `json:"access"`
  }{
    Access: []as.AccessItem{accessItem},
  }

  // Merchant
  merchantIncomingPaymentGrant, err := client.Grant.Request(context.TODO(), op.GrantRequestParams{
    URL:         *merchantWalletAddress.AuthServer,
    RequestBody: as.GrantRequestWithAccessToken{AccessToken: accessToken},
  })
  if err != nil {
    log.Fatalf("Error requesting merchant incoming payment grant: %v\n", err)
  }

  // Platform
  platformIncomingPaymentGrant, err := client.Grant.Request(context.TODO(), op.GrantRequestParams{
    URL:         *platformWalletAddress.AuthServer,
    RequestBody: as.GrantRequestWithAccessToken{AccessToken: accessToken},
  })
  if err != nil {
    log.Fatalf("Error requesting platform incoming payment grant: %v\n", err)
  }
  ```
</TabItem>
</Tabs>

<details>
<summary>Example response</summary>
The following shows an example response from the merchant's wallet provider. A similar response will be returned from your wallet provider.

```json wrap
{
  "access_token": {
    "value": "...", // access token value for incoming payment grant
    "manage": "https://happylifebank.example.com/token/{...}", // management uri for access token
    "access": [
      {
        "type": "incoming-payment",
        "actions": ["create"]
      }
    ]
  },
  "continue": {
    "access_token": {
      "value": "..." // access token for continuing the request
    },
    "uri": "https://happylifebank.example.com/continue/{...}" // continuation request uri
  }
}
```

</details>

### 3. Request the creation of incoming payment resources

Use the access tokens returned in the previous responses to call the <Badge text="POST" variant="success" /> [Create Incoming Payment API](/apis/resource-server/operations/create-incoming-payment).

This call requests an incoming payment resource be created on the merchant's wallet account and your wallet account.

Remember that the merchant is receiving 99% of the payment (\$99.00 or `9900`) while you are keeping 1% as a fee (\$1.00 or `100`).

<Tabs syncKey="lang">
  <TabItem label='TypeScript/JavaScript' icon='seti:javascript'>
  ```ts wrap
  // Merchant
  const merchantIncomingPayment = await client.incomingPayment.create(
    {
      url: merchantWalletAddress.resourceServer,
      accessToken: merchantIncomingPaymentGrant.access_token.value
    },
    {
      walletAddress: merchantWalletAddress.id,
      incomingAmount: {
        value: '9900',
        assetCode: 'USD',
        assetScale: 2
      },
    },
  )
  // Platform
  const platformIncomingPayment = await client.incomingPayment.create(
    {
      url: platformWalletAddress.resourceServer,
      accessToken: platformIncomingPaymentGrant.access_token.value
    },
    {
      walletAddress: platformWalletAddress.id,
      incomingAmount: {
        value: '100',
        assetCode: 'USD',
        assetScale: 2
      },
    },
  )
```
</TabItem>

<TabItem label='Rust' icon='seti:rust'>
 ```rust wrap
 use open_payments::types::{IncomingPaymentRequest, Amount};
 let merchant_request = IncomingPaymentRequest {
   wallet_address: merchant_wallet_address.id.clone(),
   incoming_amount: Some(Amount { value: "9900".into(), asset_code: "USD".into(), asset_scale: 2 }),
   expires_at: None,
   metadata: None,
 };
 let platform_request = IncomingPaymentRequest {
   wallet_address: platform_wallet_address.id.clone(),
   incoming_amount: Some(Amount { value: "100".into(), asset_code: "USD".into(), asset_scale: 2 }),
   expires_at: None,
   metadata: None,
 };
 let merchant_incoming_payment = client
   .incoming_payments()
   .create(&merchant_wallet_address.resource_server, &merchant_request, Some(&merchant_incoming_payment_grant.access_token.value))
   .await?;
 let platform_incoming_payment = client
   .incoming_payments()
   .create(&platform_wallet_address.resource_server, &platform_request, Some(&platform_incoming_payment_grant.access_token.value))
   .await?;
 ```
 </TabItem>

  <TabItem label='Go' icon='seti:go'>
  
  ```go wrap
  // Merchant
  merchantIncomingPayment, err := client.IncomingPayment.Create(context.TODO(), op.IncomingPaymentCreateParams{
    BaseURL:     *merchantWalletAddress.ResourceServer,
    AccessToken: merchantIncomingPaymentGrant.AccessToken.Value,
    Payload: rs.CreateIncomingPaymentJSONBody{
      WalletAddressSchema: *merchantWalletAddress.Id,
      IncomingAmount: &rs.Amount{
        Value:      "9900",
        AssetCode:  "USD",
        AssetScale: 2,
      },
    },
  })
  if err != nil {
    log.Fatalf("Error creating merchant incoming payment: %v\n", err)
  }

  // Platform
  platformIncomingPayment, err := client.IncomingPayment.Create(context.TODO(), op.IncomingPaymentCreateParams{
    BaseURL:     *platformWalletAddress.ResourceServer,
    AccessToken: platformIncomingPaymentGrant.AccessToken.Value,
    Payload: rs.CreateIncomingPaymentJSONBody{
      WalletAddressSchema: *platformWalletAddress.Id,
      IncomingAmount: &rs.Amount{
        Value:      "100",
        AssetCode:  "USD",
        AssetScale: 2,
      },
    },
  })
  if err != nil {
    log.Fatalf("Error creating platform incoming payment: %v\n", err)
  }
  ```
  </TabItem>
</Tabs>

<details>
<summary>Example response</summary>
The following shows an example response from the merchant's wallet provider. A similar response will be returned from your wallet provider, but your incoming amount `value` will be `100`.

```json wrap
{
  "id": "https://happylifebank.example.com/incoming-payments/{...}",
  "walletAddress": "https://happylifebank.example.com/merchant",
  "incomingAmount": {
    "value": "9900",
    "assetCode": "USD",
    "assetScale": 2
  },
  "receivedAmount": {
    "value": "0",
    "assetCode": "USD",
    "assetScale": 2
  },
  "completed": false,
  "createdAt": "2025-03-12T23:20:50.52Z",
  "methods": [
    {
      "type": "ilp",
      "ilpAddress": "...",
      "sharedSecret": "..."
    }
  ]
}
```

</details>

### 4. Request a quote grant

Use the customer's `authServer` details, received in Step 1, to call the <Badge text="POST" variant="success" /> [Grant Request API](/apis/auth-server/operations/post-request).

This call obtains an access token that allows your platform to request quote resources be created on the customer's wallet account.

<Tabs syncKey="lang">
  <TabItem label='TypeScript/JavaScript' icon='seti:javascript'>
    ```ts wrap
    const customerQuoteGrant = await client.grant.request(
      {
        url: customerWalletAddress.authServer
      },
      {
        access_token: {
          access: [
            {
              type: 'quote',
              actions: ['create']
            }
          ]
        }
      }
    )
    ```
  </TabItem>

  <TabItem label='Rust' icon='seti:rust'>
    ```rust wrap
    use open_payments::types::{AccessTokenRequest, AccessItem, QuoteAction, GrantRequest};
    let quote_access = AccessTokenRequest {
      access: vec![AccessItem::Quote { actions: vec![QuoteAction::Create] }],
    };
    let customer_grant_request = GrantRequest::new(quote_access, None);
    let customer_quote_grant = client
      .grant()
      .request(&customer_wallet_address.auth_server, &customer_grant_request)
      .await?;
    ```
  </TabItem>

  <TabItem label='Go' icon='seti:go'>
  
  ```go wrap
  quoteAccess := as.AccessQuote{
    Type:    as.Quote,
    Actions: []as.AccessQuoteActions{as.Create},
  }
  quoteAccessItem := as.AccessItem{}
  if err := quoteAccessItem.FromAccessQuote(quoteAccess); err != nil {
    log.Fatalf("Error creating AccessItem: %v\n", err)
  }
  quoteAccessToken := struct {
    Access as.Access `json:"access"`
  }{
    Access: []as.AccessItem{quoteAccessItem},
  }

  customerQuoteGrant, err := client.Grant.Request(context.TODO(), op.GrantRequestParams{
    URL:         *customerWalletAddress.AuthServer,
    RequestBody: as.GrantRequestWithAccessToken{AccessToken: quoteAccessToken},
  })
  if err != nil {
    log.Fatalf("Error requesting quote grant: %v\n", err)
  }
  ```
  </TabItem>
</Tabs>

<details>
  <summary>Example response</summary>

```json wrap
{
  "access_token": {
    "value": "...", // access token value for quote grant
    "manage": "https:/cloudninebank.example.com/token/{...}", // management uri for access token
    "access": [
      {
        "type": "quote",
        "actions": ["create"]
      }
    ]
  },
  "continue": {
    "access_token": {
      "value": "..." // access token for continuing the request
    },
    "uri": "https://auth.cloudninebank.example.com/continue/{...}" // continuation request uri
  }
}
```

</details>

### 5. Request the creation of quote resources

Use the access token, received in the previous step, to call the <Badge text="POST" variant="success" /> [Create Quote API](/apis/resource-server/operations/create-quote).

This call requests a quote resource be created on the customer's wallet account. Since the customer needs to get a quote for both of the incoming payments at the merchant and the platform, we'll call the API twice using the same access token.

First, let's request a quote resource associated with the merchant. The request must contain the `receiver`, which is the merchant's incoming payment `id`, along with any other required parameters. The `id` was returned in the Create an Incoming Payment API response in Step 3.

Next, call the <Badge text="POST" variant="success" /> Create Quote API again and request a quote resource associated with the platform's incoming payment `id`.

<Tabs syncKey="lang">
<TabItem label='TypeScript/JavaScript' icon='seti:javascript'>
  ```ts wrap
  // Merchant
  const merchantQuote = await client.quote.create(
    {
      url: customerWalletAddress.resourceServer,
      accessToken: customerQuoteGrant.access_token.value
    },
    {
      method: 'ilp',
      walletAddress: customerWalletAddress.id,
      receiver: merchantIncomingPayment.id
    }
  )
  // Platform
  const platformQuote = await client.quote.create(
    {
      url: customerWalletAddress.resourceServer,
      accessToken: customerQuoteGrant.access_token.value
    },
    {
      method: 'ilp',
      walletAddress: customerWalletAddress.id,
      receiver: platformIncomingPayment.id
    }
  )
```
 </TabItem>
 <TabItem label='Rust' icon='seti:rust'>
 ```rust wrap
 use open_payments::types::{QuoteRequest, QuoteMethod};
 let merchant_quote_request = QuoteRequest {
   method: QuoteMethod::Ilp,
   wallet_address: Some(customer_wallet_address.id.clone()),
   receiver: Some(merchant_incoming_payment.id.clone()),
   debit_amount: None,
   receive_amount: None,
 };
 let platform_quote_request = QuoteRequest {
   method: QuoteMethod::Ilp,
   wallet_address: Some(customer_wallet_address.id.clone()),
   receiver: Some(platform_incoming_payment.id.clone()),
   debit_amount: None,
   receive_amount: None,
 };
 let merchant_quote = client
   .quotes()
   .create(&customer_wallet_address.resource_server, &merchant_quote_request, Some(&customer_quote_grant.access_token.value))
   .await?;
 let platform_quote = client
   .quotes()
   .create(&customer_wallet_address.resource_server, &platform_quote_request, Some(&customer_quote_grant.access_token.value))
   .await?;
 ```
 </TabItem>
 <TabItem label='Go' icon='seti:go'>
  
  ```go wrap
  // Merchant
  merchantQuote, err := client.Quote.Create(context.TODO(), op.QuoteCreateParams{
    BaseURL:     *customerWalletAddress.ResourceServer,
    AccessToken: customerQuoteGrant.AccessToken.Value,
    Payload: rs.CreateQuoteJSONBody0{
      WalletAddressSchema: *customerWalletAddress.Id,
      Receiver:            *merchantIncomingPayment.Id,
      Method:              "ilp",
    },
  })
  if err != nil {
    log.Fatalf("Error creating merchant quote: %v\n", err)
  }

  // Platform
  platformQuote, err := client.Quote.Create(context.TODO(), op.QuoteCreateParams{
    BaseURL:     *customerWalletAddress.ResourceServer,
    AccessToken: customerQuoteGrant.AccessToken.Value,
    Payload: rs.CreateQuoteJSONBody0{
      WalletAddressSchema: *customerWalletAddress.Id,
      Receiver:            *platformIncomingPayment.Id,
      Method:              "ilp",
    },
  })
  if err != nil {
    log.Fatalf("Error creating platform quote: %v\n", err)
  }
  ```
</TabItem>
</Tabs>

Each response returns a `receiveAmount`, a `debitAmount`, and other required information.

- `debitAmount` - The amount the customer must pay toward the incoming payment resource (`receiveAmount` plus any applicable fees)
- `receiveAmount` - The `incomingAmount` value from the incoming payment resource

<details>
<summary>Example response</summary>
  The following shows an example response from the merchant's wallet provider. A similar response will be returned from your wallet provider.

```json wrap
{
  "id": "https://cloudninebank.example.com/quotes/{...}", // url identifying the quote
  "walletAddress": "https://cloudninebank.example.com/customer",
  "receiver": "https://happylifebank.example.com/incoming-payments/{...}", // url of the incoming payment the quote is created for
  "debitAmount": {
    "value": "9900",
    "assetCode": "USD",
    "assetScale": 2
  },
  "receiveAmount": {
    "value": "9900",
    "assetCode": "USD",
    "assetScale": 2
  },
  "method": "ilp",
  "createdAt": "2025-03-12T23:22:51.50Z"
}
```

</details>

### 6. Request an interactive outgoing payment grant

Use the customer's `authServer` information received in Step 1 to call the <Badge text="POST" variant="success" /> [Grant Request API](/apis/auth-server/operations/post-request).

This call obtains an access token that allows your platform to request outgoing payment resources be created on the customer's wallet account.

:::note

<InteractionReq />
:::

<Tabs syncKey="lang">
<TabItem label='TypeScript/JavaScript' icon='seti:javascript'>
  ```ts wrap
  const combinedQuoteAmount = quote1.debitAmount.value + // '9900'
                              quote2.debitAmount.value // '100'
  
  const pendingCustomerOutgoingPaymentGrant = await client.grant.request(
    {
      url: customerWalletAddress.authServer
    },
    {
      access_token: {
        access: [
          {
            identifier: customerWalletAddress.id,
            type: 'outgoing-payment',
            actions: ['create'],
            limits: {
              debitAmount: {
                assetCode: 'USD',
                assetScale: 2,
                value: combinedQuoteAmount,
              }
            }
          }
        ]
      },
      interact: {
        start: ['redirect'],
        finish: {
          method: 'redirect',
          uri: 'https://paymentplatform.example/finish/{...}', // where to redirect the customer after they've completed interaction
          nonce: NONCE
        }
      }
    }
  )
  ```
 </TabItem>
 <TabItem label='Rust' icon='seti:rust'>
 ```rust wrap
 use open_payments::types::{AccessTokenRequest, AccessItem, OutgoingPaymentAction, InteractRequest, InteractStart, InteractFinish, InteractFinishMethod, AccessLimits, Amount, GrantRequest};
 
 let merchant_amount = match merchant_quote.debit_amount.as_ref() {
   Some(a) => &a.value,
   None => {
     eprintln!("Missing debit_amount on merchant quote");
     return Ok(());
   }
 };
 let platform_amount = match platform_quote.debit_amount.as_ref() {
   Some(a) => &a.value,
   None => {
     eprintln!("Missing debit_amount on platform quote");
     return Ok(());
   }
 };
 let merchant_value = match merchant_amount.parse::<i64>() {
   Ok(v) => v,
   Err(_) => {
     eprintln!("Invalid merchant debit_amount value");
     return Ok(());
   }
 };
 let platform_value = match platform_amount.parse::<i64>() {
   Ok(v) => v,
   Err(_) => {
     eprintln!("Invalid platform debit_amount value");
     return Ok(());
   }
 };
 let combined_quote_amount = merchant_value + platform_value;
 let outgoing_access = AccessTokenRequest {
   access: vec![AccessItem::OutgoingPayment {
     identifier: Some(customer_wallet_address.id.clone()),
     actions: vec![OutgoingPaymentAction::Create],
     limits: Some(AccessLimits { debit_amount: Some(Amount { value: combined_quote_amount.to_string(), asset_code: "USD".into(), asset_scale: 2 }), ..Default::default() }),
   }],
 };
 let interact = InteractRequest { start: Some(vec![InteractStart::Redirect]), finish: Some(InteractFinish { method: InteractFinishMethod::Redirect, uri: Some("https://paymentplatform.example/finish/{...}".into()), nonce: Some("NONCE".into()) }) };
 let outgoing_grant_request = GrantRequest::new(outgoing_access, Some(interact));
 let pending_customer_outgoing_payment_grant = client
   .grant()
   .request(&customer_wallet_address.auth_server, &outgoing_grant_request)
   .await?;
 ```
 </TabItem>

  <TabItem label='Go' icon='seti:go'>
  
  ```go wrap
  combinedQuoteAmount := "10000" // merchantQuote.DebitAmount.Value + platformQuote.DebitAmount.Value

  limits := as.LimitsOutgoing{}
  if err := limits.FromLimitsOutgoing1(as.LimitsOutgoing1{
    DebitAmount: as.Amount{
      Value:      combinedQuoteAmount,
      AssetCode:  "USD",
      AssetScale: 2,
    },
  }); err != nil {
    log.Fatalf("Error creating limits: %v\n", err)
  }

  outgoingAccess := as.AccessOutgoing{
    Type:       as.OutgoingPayment,
    Actions:    []as.AccessOutgoingActions{as.AccessOutgoingActionsCreate},
    Identifier: *customerWalletAddress.Id,
    Limits:     &limits,
  }
  outgoingAccessItem := as.AccessItem{}
  if err := outgoingAccessItem.FromAccessOutgoing(outgoingAccess); err != nil {
    log.Fatalf("Error creating AccessItem: %v\n", err)
  }
  outgoingAccessToken := struct {
    Access as.Access `json:"access"`
  }{
    Access: []as.AccessItem{outgoingAccessItem},
  }
  interact := &as.InteractRequest{
    Start: []as.InteractRequestStart{as.InteractRequestStartRedirect},
    Finish: &as.InteractRequestFinish{
      Method: as.Redirect,
      Uri:    "https://paymentplatform.example/finish/{...}", // where to redirect the customer after they've completed interaction
      Nonce:  NONCE,
    },
  }

  pendingCustomerOutgoingPaymentGrant, err := client.Grant.Request(context.TODO(), op.GrantRequestParams{
    URL: *customerWalletAddress.AuthServer,
    RequestBody: as.GrantRequestWithAccessToken{
      AccessToken: outgoingAccessToken,
      Interact:    interact,
    },
  })
  if err != nil {
    log.Fatalf("Error requesting outgoing payment grant: %v\n", err)
  }
  ```
  </TabItem>
</Tabs>

<details>
  <summary>Example response</summary>

```json wrap
{
  "interact": {
    "redirect": "https://auth.cloudninebank.example.com/{...}", // uri to redirect the customer to, to begin interaction
    "finish": "..." // unique key to secure the callback
  },
  "continue": {
    "access_token": {
      "value": "..." // access token for continuing the outgoing payment grant request
    },
    "uri": "https://auth.cloudninebank.example.com/continue/{...}", // uri for continuing the outgoing payment grant request
    "wait": 30
  }
}
```

</details>

### 7. Start interaction with the customer

<StartInteraction />

### 8. Finish interaction with the customer

<FinishInteraction />

### 9. Request a grant continuation

In our example, we're assuming the IdP the customer interacted with has a user interface. When the interaction completes, the customer returns to your platform. Now your platform can make a continuation request for the outgoing payment grant.

:::note
In a scenario where a user interface isn't available, consider implementing a polling mechanism to check for the completion of the interaction.
:::

Call the <Badge text="POST" variant="success" /> [Grant Continuation Request API](/apis/auth-server/operations/post-continue). This call requests an access token that allows your platform to request outgoing payment resources be created on the customer's wallet account.

Issue the request to the `continue.uri` provided in the initial outgoing payment grant response (Step 6).

Include the `interact_ref` returned in the redirect URI's query parameters.

<Tabs syncKey="lang">
  <TabItem label='TypeScript/JavaScript' icon='seti:javascript'>
    ```ts wrap
    const customerOutgoingPaymentGrant = await client.grant.continue(
      {
        url: pendingCustomerOutgoingPaymentGrant.continue.uri,
        accessToken: pendingCustomerOutgoingPaymentGrant.continue.access_token.value
      },
      {
        interact_ref: interactRef
      }
    )
    ```
  </TabItem>
 <TabItem label='Rust' icon='seti:rust'>
 ```rust wrap
 let customer_outgoing_payment_grant = client
   .grant()
   .continue_grant(
     if let Some(continue_field) = &pending_customer_outgoing_payment_grant.continue_field { &continue_field.uri } else { eprintln!("Missing continue field on pending grant"); return Ok(()); },
     &interact_ref,
     if let Some(continue_field) = &pending_customer_outgoing_payment_grant.continue_field { Some(&continue_field.access_token.value) } else { None },
   )
   .await?;
 ```
 </TabItem>

 <TabItem label='Go' icon='seti:go'>
  
  ```go wrap
  customerOutgoingPaymentGrant, err := client.Grant.Continue(context.TODO(), op.GrantContinueParams{
    URL:         pendingCustomerOutgoingPaymentGrant.Continue.Uri,
    AccessToken: pendingCustomerOutgoingPaymentGrant.Continue.AccessToken.Value,
    InteractRef: INTERACT_REF
  })
  if err != nil {
    log.Fatalf("Error continuing grant: %v\n", err)
  }
  ```
  </TabItem>
</Tabs>

<details>
  <summary>Example response</summary>

```json wrap
{
  "access_token": {
    "value": "...", // final access token required before creating outgoing payments
    "manage": "https://auth.cloudninebank.example.com/token/{...}", // management uri for access token
    "access": [
      {
        "type": "outgoing-payment",
        "actions": ["create"],
        "identifier": "https://cloudninebank.example.com/customer",
        "limits": {
          "receiver": "https://happylifebank.example.com/incoming-payments/{...}" // url of the incoming payment that's being paid
        }
      }
    ]
  },
  "continue": {
    "access_token": {
      "value": "..." // access token for continuing the request
    },
    "uri": "https://auth.cloudninebank.example.com/continue/{...}" // continuation request uri
  }
}
```

</details>

### 10. Request the creation of outgoing payment resources

Recall that the Create Quote API responses for the merchant and your platform (Step 5) both included a `debitAmount` and a `receiveAmount`. The responses also included an `id` which is a URL to identify each quote.

Because the quotes contain debit and receive amounts, we won't specify any other amounts when setting up the outgoing payments. Instead, we will specify a `quoteId`.

Use the access token returned in Step 5 that's associated with the merchant to call the <Badge text="POST" variant="success" /> [Create Outgoing Payment API](/apis/resource-server/operations/create-outgoing-payment). Include the appropriate `quoteId` in the request. Now, do the same with the access token associated with your platform.

<Tabs syncKey="lang">
<TabItem label='TypeScript/JavaScript' icon='seti:javascript'>
  ```ts wrap
  // Merchant
  const customerOutgoingPaymentToMerchant = await client.outgoingPayment.create(
    {
      url: customerWalletAddress.resourceServer,
      accessToken: customerOutgoingPaymentGrant.access_token.value
    },
    {
      walletAddress: customerWalletAddress.id,
      quoteId: merchantQuote.id
    }
  )
  // Platform
  const customerOutgoingPaymentToPlatform = await client.outgoingPayment.create(
    {
      url: customerWalletAddress.resourceServer,
      accessToken: customerOutgoingPaymentGrant.access_token.value
    },
    {
      walletAddress: customerWalletAddress.id,
      quoteId: platformQuote.id
    }
  )
```
 </TabItem>
 <TabItem label='Rust' icon='seti:rust'>
 ```rust wrap
 use open_payments::types::OutgoingPaymentRequest;
 let merchant_outgoing_request = OutgoingPaymentRequest {
   wallet_address: customer_wallet_address.id.clone(),
   receiver: Some(merchant_incoming_payment.id.clone()),
   debit_amount: None,
   receive_amount: None,
   quote_id: Some(merchant_quote.id.clone()),
 };
 let platform_outgoing_request = OutgoingPaymentRequest {
   wallet_address: customer_wallet_address.id.clone(),
   receiver: Some(platform_incoming_payment.id.clone()),
   debit_amount: None,
   receive_amount: None,
   quote_id: Some(platform_quote.id.clone()),
 };
 let customer_outgoing_payment_to_merchant = client
   .outgoing_payments()
   .create(&customer_wallet_address.resource_server, &merchant_outgoing_request, Some(&customer_outgoing_payment_grant.access_token.value))
   .await?;
 let customer_outgoing_payment_to_platform = client
   .outgoing_payments()
   .create(&customer_wallet_address.resource_server, &platform_outgoing_request, Some(&customer_outgoing_payment_grant.access_token.value))
   .await?;
 ```
 </TabItem>

  <TabItem label='Go' icon='seti:go'>
  
  ```go wrap
  // Merchant
  var merchantOutgoingPayload rs.CreateOutgoingPaymentRequest
  if err := merchantOutgoingPayload.FromCreateOutgoingPaymentWithQuote(rs.CreateOutgoingPaymentWithQuote{
    WalletAddressSchema: *customerWalletAddress.Id,
    QuoteId:             *merchantQuote.Id,
  }); err != nil {
    log.Fatalf("Error creating merchant payload: %v\n", err)
  }

  customerOutgoingPaymentToMerchant, err := client.OutgoingPayment.Create(context.TODO(), op.OutgoingPaymentCreateParams{
    BaseURL:     *customerWalletAddress.ResourceServer,
    AccessToken: customerOutgoingPaymentGrant.AccessToken.Value,
    Payload:     merchantOutgoingPayload,
  })
  if err != nil {
    log.Fatalf("Error creating outgoing payment to merchant: %v\n", err)
  }

  // Platform
  var platformOutgoingPayload rs.CreateOutgoingPaymentRequest
  if err := platformOutgoingPayload.FromCreateOutgoingPaymentWithQuote(rs.CreateOutgoingPaymentWithQuote{
    WalletAddressSchema: *customerWalletAddress.Id,
    QuoteId:             *platformQuote.Id,
  }); err != nil {
    log.Fatalf("Error creating platform payload: %v\n", err)
  }

  customerOutgoingPaymentToPlatform, err := client.OutgoingPayment.Create(context.TODO(), op.OutgoingPaymentCreateParams{
    BaseURL:     *customerWalletAddress.ResourceServer,
    AccessToken: customerOutgoingPaymentGrant.AccessToken.Value,
    Payload:     platformOutgoingPayload,
  })
  if err != nil {
    log.Fatalf("Error creating outgoing payment to platform: %v\n", err)
  }
  ```
  </TabItem>
</Tabs>

<details>
<summary>Example response</summary>
The following shows an example response when an outgoing payment resource is created on the customer's account for the merchant. A similar response will be returned when an outgoing payment resource is created for you, as the wallet provider.

```json wrap
{
  "id": "https://cloudninebank.example.com/outgoing-payments/{...}", // url identifying the outgoing payment
  "walletAddress": "https://cloudninebank.example.com/customer",
  "receiver": "https://happylifebank.example.com/incoming-payments/{...}", // url of the incoming payment being paid
  "debitAmount": {
    "value": "9900",
    "assetCode": "USD",
    "assetScale": 2
  },
  "receiveAmount": {
    "value": "9900",
    "assetCode": "USD",
    "assetScale": 2
  },
  "sentAmount": {
    "value": "0",
    "assetCode": "USD",
    "assetScale": 2
  },
  "createdAt": "2022-03-12T23:20:54.52Z"
}
```

</details>

---
title: Dividir un pago entrante
---

import { LinkOut } from '@interledger/docs-design-system'
import { Tabs, TabItem, Badge } from '@astrojs/starlight/components'
import InteractionReq from '/src/partials/es/interaction-required.mdx'
import StartInteraction from '/src/partials/es/grant-start-interaction.mdx'
import FinishInteraction from '/src/partials/es/grant-finish-interaction.mdx'

:::tip[Resumen]
Conozca cómo tomar un único pago y dividir el valor entre varios destinatarios.
:::

Imagine realizar una compra en un mercado en línea. Desde su perspectiva, envía un único pago a un comerciante a cambio de un producto. En un segundo plano, el mercado recibe una parte del pago como tarifa por el servicio.

Existen varias formas de que el mercado cobre la tarifa. Por ejemplo, podría recibir el monto completo, deducir la tarifa y, luego, enviar el resto al comerciante. Sin embargo, retener fondos para el comerciante, aunque sea por un segundo, requiere cumplir con ciertas normas y reglamentaciones financieras. Una mejor manera consiste en asegurarse de que ambas partes reciban directamente del usuario solo el monto que les corresponde.

Recuerde que Open Payments no ejecuta pagos ni toca dinero de ninguna manera. Se usa para emitir instrucciones de pago antes de que se produzca cualquier movimiento de dinero. Entre los ejemplos de instrucciones de pago se encuentran: “de la compra de \$6, pague \$1 al mercado y $5 al comerciante”. De este modo, los fondos destinados a una parte nunca pasan por la otra.

En el marco de esta guía, usted asumirá el rol de operador de una plataforma de mercado en línea. La guía explica cómo dividir el pago de USD 100 de un consumidor en dos pagos entrantes. El comerciante recibirá el 99 % del pago mientras que usted retiene el 1 % como tarifa.

Las tres partes que intervienen en la transacción son las siguientes:

- Consumidor: el comprador de un bien o servicio en el mercado.
- Comerciante: el vendedor de un bien o servicio en el mercado.
- Operador de la plataforma: usted, como operador del mercado.

## Puntos finales

- <Badge text="GET" variant="note" />
  <LinkOut href="https://openpayments.dev/apis/wallet-address-server/operations/get-wallet-address/">
    Get Wallet Address
  </LinkOut>
- <Badge text="POST" variant="success" />
  <LinkOut href="https://openpayments.dev/apis/auth-server/operations/post-request/">
    Grant Request
  </LinkOut>
- <Badge text="POST" variant="success" />
  <LinkOut href="https://openpayments.dev/apis/resource-server/operations/create-incoming-payment/">
    Create an Incoming Payment
  </LinkOut>
- <Badge text="POST" variant="success" />
  <LinkOut href="https://openpayments.dev/apis/resource-server/operations/create-quote/">
    Create a Quote
  </LinkOut>
- <Badge text="POST" variant="success" />
  <LinkOut href="https://openpayments.dev/apis/resource-server/operations/create-outgoing-payment/">
    Create an Outgoing Payment
  </LinkOut>

## Pasos

### 1. Obtener los datos de la dirección de billetera

Cuando un consumidor inicia un pago, su plataforma debe obtener la información de dirección de la billetera del consumidor, del comerciante y de usted, en carácter de operador.

Supongamos que la dirección de la billetera ya se encuentra guardada en su plataforma, al igual que la del comerciante. Supongamos además que el consumidor proporcionó su dirección de billetera al comienzo del proceso de pago.

Llame a la <Badge text="GET" variant="note" /> [Get Wallet Address](/es/apis/wallet-address-server/operations/get-wallet-address) para cada dirección.

<Tabs syncKey="lang">
<TabItem label='TypeScript/JavaScript' icon='seti:javascript'>
  ```ts
  const customerWalletAddress = await client.walletAddress.get({
    url: 'https://cloudninebank.example.com/customer'
  })

const merchantWalletAddress = await client.walletAddress.get({
url: 'https://happylifebank.example.com/merchant'
})

const platformWalletAddress = await client.walletAddress.get({
url: 'https://coolwallet.example.com/platform'
})

````
</TabItem>
 <TabItem label='Rust' icon='seti:rust'>
 ```rust wrap
 let customer_wallet_address = client.wallet_address().get("https://cloudninebank.example.com/customer").await?;
 let merchant_wallet_address = client.wallet_address().get("https://happylifebank.example.com/merchant").await?;
 let platform_wallet_address = client.wallet_address().get("https://coolwallet.example.com/platform").await?;
 ```
 </TabItem>
  <TabItem label='Go' icon='seti:go'>

  ```go wrap
  customerWalletAddress, err := client.WalletAddress.Get(context.TODO(), op.WalletAddressGetParams{
    URL: "https://cloudninebank.example.com/customer",
  })
  if err != nil {
    log.Fatalf("Error fetching customer wallet address: %v\n", err)
  }
  merchantWalletAddress, err := client.WalletAddress.Get(context.TODO(), op.WalletAddressGetParams{
    URL: "https://happylifebank.example.com/merchant",
  })
  if err != nil {
    log.Fatalf("Error fetching merchant wallet address: %v\n", err)
  }
  platformWalletAddress, err := client.WalletAddress.Get(context.TODO(), op.WalletAddressGetParams{
    URL: "https://coolwallet.example.com/platform",
  })
  if err != nil {
    log.Fatalf("Error fetching platform wallet address: %v\n", err)
  }
  ```
  </TabItem>
</Tabs>

### 2. Solicitar concesiones de autorización de pagos entrantes

Utilice los datos del comerciante y de la plataforma `authServer`, recibidos en el paso anterior, para llamar a la <Badge text="POST" variant="success" /> [Grant Request API](/es/apis/auth-server/operations/post-request).

El propósito de estas llamadas consiste en obtener tókenes de acceso que permitan a su plataforma solicitar la creación de un recurso de pago entrante en la cuenta de la billetera del comerciante y en su cuenta de billetera.

:::note[Situación alternativa]
Si usted y el comerciante utilizan la misma entidad que administra cuentas, y la información del servidor de autorización que se recibió es la misma para ambos, solo necesita una concesión `incomingPayment`.
:::

<Tabs syncKey="lang">
<TabItem label='TypeScript/JavaScript' icon='seti:javascript'>
  ```ts wrap
  // Merchant
  const merchantIncomingPaymentGrant = await client.grant.request(
    {
      url: merchantWalletAddress.authServer
    },
    {
      access_token: {
        access: [
          {
            type: "incoming-payment",
            actions: ["create"]
          }
        ]
      }
    }
  );
  // Platform
  const platformIncomingPaymentGrant = await client.grant.request(
    {
      url: platformWalletAddress.authServer
    },
    {
      access_token: {
        access: [
          {
            type: "incoming-payment",
            actions: ["create"]
          }
        ]
      }
    }
  );
  ```
 </TabItem>

<TabItem label='Rust' icon='seti:rust'>
 ```rust wrap
 use open_payments::types::{AccessTokenRequest, AccessItem, IncomingPaymentAction, GrantRequest};
 let incoming_access = AccessTokenRequest {
   access: vec![AccessItem::IncomingPayment { actions: vec![IncomingPaymentAction::Create], identifier: None }],
 };
 let merchant_grant_request = GrantRequest::new(incoming_access.clone(), None);
 let platform_grant_request = GrantRequest::new(incoming_access, None);
 let merchant_incoming_payment_grant = client
   .grant()
   .request(&merchant_wallet_address.auth_server, &merchant_grant_request)
   .await?;
 let platform_incoming_payment_grant = client
   .grant()
   .request(&platform_wallet_address.auth_server, &platform_grant_request)
   .await?;
 ```
 </TabItem>

  <TabItem label='Go' icon='seti:go'>

```go wrap
incomingAccess := as.AccessIncoming{
  Type:    as.IncomingPayment,
  Actions: []as.AccessIncomingActions{as.AccessIncomingActionsCreate},
}
accessItem := as.AccessItem{}
if err := accessItem.FromAccessIncoming(incomingAccess); err != nil {
  log.Fatalf("Error creating AccessItem: %v\n", err)
}
accessToken := struct {
  Access as.Access `json:"access"`
}{
  Access: []as.AccessItem{accessItem},
}
// Merchant
merchantIncomingPaymentGrant, err := client.Grant.Request(context.TODO(), op.GrantRequestParams{
  URL:         *merchantWalletAddress.AuthServer,
  RequestBody: as.GrantRequestWithAccessToken{AccessToken: accessToken},
})
if err != nil {
  log.Fatalf("Error requesting merchant incoming payment grant: %v\n", err)
}
// Platform
platformIncomingPaymentGrant, err := client.Grant.Request(context.TODO(), op.GrantRequestParams{
  URL:         *platformWalletAddress.AuthServer,
  RequestBody: as.GrantRequestWithAccessToken{AccessToken: accessToken},
})
if err != nil {
  log.Fatalf("Error requesting platform incoming payment grant: %v\n", err)
}
```

  </TabItem>
</Tabs>

### 3. Solicitar la creación de recursos de pagos entrantes

Use los tókenes de acceso devueltos en las respuestas anteriores para llamar a la <Badge text="POST" variant="success" /> [Create an Incoming Payment API](/es/apis/resource-server/operations/create-incoming-payment).

El propósito de estas llamadas consiste en solicitar la creación de un recurso de pago entrante en la cuenta de la billetera del comerciante y en su cuenta de billetera.

Recuerde que usted retiene el 1 % del pago de USD 100 del consumidor como tarifa.

Incluya lo siguiente en ambas solicitudes, junto con cualquier otro parámetro requerido:

- Objeto `incomingAmount`
  - `value`: el monto máximo a pagar en una dirección de billetera determinada.
  - `assetCode`: el código utilizado por la cuenta de la billetera, proporcionado en la respuesta de la Get Wallet Address API.
  - `assetScale`: la escala utilizada por la cuenta de la billetera, proporcionada en la respuesta de la Get Wallet Address API.

El `value` total de $100 es `10000`. El comerciante recibirá el 99 % (`9900`) y usted recibirá el 1 % (`100`).

<Tabs syncKey="lang">
  <TabItem label='TypeScript/JavaScript' icon='seti:javascript'>
  ```ts wrap
  // Merchant
  const merchantIncomingPayment = await client.incomingPayment.create(
    {
      url: merchantWalletAddress.resourceServer,
      accessToken: merchantIncomingPaymentGrant.access_token.value
    },
    {
      walletAddress: merchantWalletAddress.id,
      incomingAmount: {
        value: '9900',
        assetCode: 'USD',
        assetScale: 2
      }
    }
  )
  // Platform
  const platformIncomingPayment = await client.incomingPayment.create(
    {
      url: platformWalletAddress.resourceServer,
      accessToken: platformIncomingPaymentGrant.access_token.value
    },
    {
      walletAddress: platformWalletAddress.id,
      incomingAmount: {
        value: '100',
        assetCode: 'USD',
        assetScale: 2
      }
    }
  )
```
</TabItem>
<TabItem label='Rust' icon='seti:rust'>
 ```rust wrap
 use open_payments::types::{IncomingPaymentRequest, Amount};
 let merchant_request = IncomingPaymentRequest {
   wallet_address: merchant_wallet_address.id.clone(),
   incoming_amount: Some(Amount { value: "9900".into(), asset_code: "USD".into(), asset_scale: 2 }),
   expires_at: None,
   metadata: None,
 };
 let platform_request = IncomingPaymentRequest {
   wallet_address: platform_wallet_address.id.clone(),
   incoming_amount: Some(Amount { value: "100".into(), asset_code: "USD".into(), asset_scale: 2 }),
   expires_at: None,
   metadata: None,
 };
 let merchant_incoming_payment = client
   .incoming_payments()
   .create(&merchant_wallet_address.resource_server, &merchant_request, Some(&merchant_incoming_payment_grant.access_token.value))
   .await?;
 let platform_incoming_payment = client
   .incoming_payments()
   .create(&platform_wallet_address.resource_server, &platform_request, Some(&platform_incoming_payment_grant.access_token.value))
   .await?;
 ```
 </TabItem>

  <TabItem label='Go' icon='seti:go'>

  ```go wrap
  // Merchant
  merchantIncomingPayment, err := client.IncomingPayment.Create(context.TODO(), op.IncomingPaymentCreateParams{
    BaseURL:     *merchantWalletAddress.ResourceServer,
    AccessToken: merchantIncomingPaymentGrant.AccessToken.Value,
    Payload: rs.CreateIncomingPaymentJSONBody{
      WalletAddressSchema: *merchantWalletAddress.Id,
      IncomingAmount: &rs.Amount{
        Value:      "9900",
        AssetCode:  "USD",
        AssetScale: 2,
      },
    },
  })
  if err != nil {
    log.Fatalf("Error creating merchant incoming payment: %v\n", err)
  }
  // Platform
  platformIncomingPayment, err := client.IncomingPayment.Create(context.TODO(), op.IncomingPaymentCreateParams{
    BaseURL:     *platformWalletAddress.ResourceServer,
    AccessToken: platformIncomingPaymentGrant.AccessToken.Value,
    Payload: rs.CreateIncomingPaymentJSONBody{
      WalletAddressSchema: *platformWalletAddress.Id,
      IncomingAmount: &rs.Amount{
        Value:      "100",
        AssetCode:  "USD",
        AssetScale: 2,
      },
    },
  })
  if err != nil {
    log.Fatalf("Error creating platform incoming payment: %v\n", err)
  }
  ```
  </TabItem>
</Tabs>

### 4. Solicitar una concesión de autorización para una cotización

Utilice los datos del consumidor `authServer`, recibidos en el paso 1, para llamar a la <Badge text="POST" variant="success" /> [Grant Request API](/es/apis/auth-server/operations/post-request).

El propósito de esta llamada consiste en obtener un token de acceso que permita a su plataforma solicitar la creación de recursos de cotización en la cuenta de la billetera del consumidor.

<Tabs syncKey="lang">
<TabItem label='TypeScript/JavaScript' icon='seti:javascript'>
  ```ts wrap
  const customerQuoteGrant = await client.grant.request(
    {
      url: customerWalletAddress.authServer
    },
    {
      access_token: {
        access: [
          {
            type: 'quote',
            actions: ['create']
          }
        ]
      }
    }
  )
  ```
</TabItem>
<TabItem label='Rust' icon='seti:rust'>
    ```rust wrap
    use open_payments::types::{AccessTokenRequest, AccessItem, QuoteAction, GrantRequest};
    let quote_access = AccessTokenRequest {
      access: vec![AccessItem::Quote { actions: vec![QuoteAction::Create] }],
    };
    let customer_grant_request = GrantRequest::new(quote_access, None);
    let customer_quote_grant = client
      .grant()
      .request(&customer_wallet_address.auth_server, &customer_grant_request)
      .await?;
    ```
  </TabItem>

  <TabItem label='Go' icon='seti:go'>

  ```go wrap
  quoteAccess := as.AccessQuote{
    Type:    as.Quote,
    Actions: []as.AccessQuoteActions{as.Create},
  }
  quoteAccessItem := as.AccessItem{}
  if err := quoteAccessItem.FromAccessQuote(quoteAccess); err != nil {
    log.Fatalf("Error creating AccessItem: %v\n", err)
  }
  quoteAccessToken := struct {
    Access as.Access `json:"access"`
  }{
    Access: []as.AccessItem{quoteAccessItem},
  }
  customerQuoteGrant, err := client.Grant.Request(context.TODO(), op.GrantRequestParams{
    URL:         *customerWalletAddress.AuthServer,
    RequestBody: as.GrantRequestWithAccessToken{AccessToken: quoteAccessToken},
  })
  if err != nil {
    log.Fatalf("Error requesting quote grant: %v\n", err)
  }
  ```
  </TabItem>
</Tabs>

### 5. Solicitar la creación de recursos de cotización

Utilice el token de acceso recibido en el paso anterior para llamar a la <Badge text="POST" variant="success" />[Create Quote API](/es/apis/resource-server/operations/create-quote).

El propósito de esta llamada consiste en solicitar la creación de un recurso de cotización en la cuenta de la billetera del consumidor. Dado que el consumidor necesita un recurso de cotización tanto para el comerciante como para la plataforma, llamaremos a la API dos veces usando el mismo token de acceso.

Primero, solicitemos un recurso de cotización asociado con el comerciante. La solicitud debe contener el `receiver`, que es la `id` del pago entrante del comerciante, junto con cualquier otro parámetro requerido. La `id` se indicó en la respuesta de la Create Incoming Payment API en el paso 3.

Posteriormente, llame de nuevo a la Create Quote API y solicite un recurso de cotización asociado con la `id` del pago entrante de la plataforma.

<Tabs syncKey="lang">
<TabItem label='TypeScript/JavaScript' icon='seti:javascript'>
  ```ts wrap
  // Merchant
  const merchantQuote = await client.quote.create(
    {
      url: customerWalletAddress.resourceServer,
      accessToken: customerQuoteGrant.access_token.value
    },
    {
      method: 'ilp',
      walletAddress: customerWalletAddress.id,
      receiver: merchantIncomingPayment.id
    }
  )
  // Platform
  const platformQuote = await client.quote.create(
    {
      url: customerWalletAddress.resourceServer,
      accessToken: customerQuoteGrant.access_token.value
    },
    {
      method: 'ilp',
      walletAddress: customerWalletAddress.id,
      receiver: platformIncomingPayment.id
    }
  )
```
 </TabItem>
<TabItem label='Rust' icon='seti:rust'>
 ```rust wrap
 use open_payments::types::{QuoteRequest, QuoteMethod};
 let merchant_quote_request = QuoteRequest {
   method: QuoteMethod::Ilp,
   wallet_address: Some(customer_wallet_address.id.clone()),
   receiver: Some(merchant_incoming_payment.id.clone()),
   debit_amount: None,
   receive_amount: None,
 };
 let platform_quote_request = QuoteRequest {
   method: QuoteMethod::Ilp,
   wallet_address: Some(customer_wallet_address.id.clone()),
   receiver: Some(platform_incoming_payment.id.clone()),
   debit_amount: None,
   receive_amount: None,
 };
 let merchant_quote = client
   .quotes()
   .create(&customer_wallet_address.resource_server, &merchant_quote_request, Some(&customer_quote_grant.access_token.value))
   .await?;
 let platform_quote = client
   .quotes()
   .create(&customer_wallet_address.resource_server, &platform_quote_request, Some(&customer_quote_grant.access_token.value))
   .await?;
 ```
 </TabItem>
 <TabItem label='Go' icon='seti:go'>

  ```go wrap
  // Merchant
  merchantQuote, err := client.Quote.Create(context.TODO(), op.QuoteCreateParams{
    BaseURL:     *customerWalletAddress.ResourceServer,
    AccessToken: customerQuoteGrant.AccessToken.Value,
    Payload: rs.CreateQuoteJSONBody0{
      WalletAddressSchema: *customerWalletAddress.Id,
      Receiver:            *merchantIncomingPayment.Id,
      Method:              "ilp",
    },
  })
  if err != nil {
    log.Fatalf("Error creating merchant quote: %v\n", err)
  }
  // Platform
  platformQuote, err := client.Quote.Create(context.TODO(), op.QuoteCreateParams{
    BaseURL:     *customerWalletAddress.ResourceServer,
    AccessToken: customerQuoteGrant.AccessToken.Value,
    Payload: rs.CreateQuoteJSONBody0{
      WalletAddressSchema: *customerWalletAddress.Id,
      Receiver:            *platformIncomingPayment.Id,
      Method:              "ilp",
    },
  })
  if err != nil {
    log.Fatalf("Error creating platform quote: %v\n", err)
  }
  ```
</TabItem>
</Tabs>

Cada respuesta devuelve un `receiveAmount`, un `debitAmount` y demás información requerida.

- `receiveAmount`: el valor del `incomingAmount` del recurso de pago entrante.
- `debitAmount`: el monto que el consumidor debe pagar al recurso de pago entrante (el `receiveAmount` más cualquier tarifa que corresponda).

### 6. Solicitar una concesión de autorización interactiva para un pago saliente

Utilice la información del consumidor `authServer` recibida en el paso 1 para llamar a la <Badge text="POST" variant="success" /> [Grant Request API](/es/apis/auth-server/operations/post-request).

El propósito de esta llamada consiste en obtener un token de acceso que permita a su plataforma solicitar la creación de recursos de pago saliente en la cuenta de la billetera del consumidor.

:::note

<InteractionReq />
:::

Incluya lo siguiente en la solicitud, además de los parámetros requeridos:

- Objeto `limits`
  - Objeto `receiveAmount`
    - `value`: el monto total que el consumidor aceptó pagar.
    - `assetCode`: el código utilizado por la cuenta de la billetera, proporcionado en la respuesta de la Get Wallet Address API.
    - `assetScale`: la escala utilizada por la cuenta de la billetera, proporcionada en la respuesta de la Get Wallet Address API.

<Tabs syncKey="lang">
<TabItem label='TypeScript/JavaScript' icon='seti:javascript'>
  ```ts wrap
  combinedQuoteAmount = '10000' // 9900 + 100

  const pendingCustomerOutgoingPaymentGrant = await client.grant.request(
    {
      url: customerWalletAddress.authServer
    },
    {
      access_token: {
        access: [
          {
            identifier: customerWalletAddress.id,
            type: 'outgoing-payment',
            actions: ['create'],
            limits: {
              debitAmount: {
                assetCode: 'USD',
                assetScale: 2,
                value: combinedQuoteAmount
              }
            }
          }
        ]
      },
      interact: {
        start: ['redirect'],
        finish: {
          method: 'redirect',
          uri: 'https://paymentplatform.example/finish/{...}', // where to redirect the customer after they've completed interaction
          nonce: NONCE
        }
      }
    }
  )
  ```
 </TabItem>
<TabItem label='Rust' icon='seti:rust'>
 ```rust wrap
 use open_payments::types::{AccessTokenRequest, AccessItem, OutgoingPaymentAction, InteractRequest, InteractStart, InteractFinish, InteractFinishMethod, AccessLimits, Amount, GrantRequest};

 let merchant_amount = match merchant_quote.debit_amount.as_ref() {
   Some(a) => &a.value,
   None => {
     eprintln!("Missing debit_amount on merchant quote");
     return Ok(());
   }
 };
 let platform_amount = match platform_quote.debit_amount.as_ref() {
   Some(a) => &a.value,
   None => {
     eprintln!("Missing debit_amount on platform quote");
     return Ok(());
   }
 };
 let merchant_value = match merchant_amount.parse::<i64>() {
   Ok(v) => v,
   Err(_) => {
     eprintln!("Invalid merchant debit_amount value");
     return Ok(());
   }
 };
 let platform_value = match platform_amount.parse::<i64>() {
   Ok(v) => v,
   Err(_) => {
     eprintln!("Invalid platform debit_amount value");
     return Ok(());
   }
 };
 let combined_quote_amount = merchant_value + platform_value;
 let outgoing_access = AccessTokenRequest {
   access: vec![AccessItem::OutgoingPayment {
     identifier: Some(customer_wallet_address.id.clone()),
     actions: vec![OutgoingPaymentAction::Create],
     limits: Some(AccessLimits { debit_amount: Some(Amount { value: combined_quote_amount.to_string(), asset_code: "USD".into(), asset_scale: 2 }), ..Default::default() }),
   }],
 };
 let interact = InteractRequest { start: Some(vec![InteractStart::Redirect]), finish: Some(InteractFinish { method: InteractFinishMethod::Redirect, uri: Some("https://paymentplatform.example/finish/{...}".into()), nonce: Some("NONCE".into()) }) };
 let outgoing_grant_request = GrantRequest::new(outgoing_access, Some(interact));
 let pending_customer_outgoing_payment_grant = client
   .grant()
   .request(&customer_wallet_address.auth_server, &outgoing_grant_request)
   .await?;
 ```
 </TabItem>

  <TabItem label='Go' icon='seti:go'>

  ```go wrap
  combinedQuoteAmount := "10000" // merchantQuote.DebitAmount.Value + platformQuote.DebitAmount.Value
  limits := as.LimitsOutgoing{}
  if err := limits.FromLimitsOutgoing1(as.LimitsOutgoing1{
    DebitAmount: as.Amount{
      Value:      combinedQuoteAmount,
      AssetCode:  "USD",
      AssetScale: 2,
    },
  }); err != nil {
    log.Fatalf("Error creating limits: %v\n", err)
  }
  outgoingAccess := as.AccessOutgoing{
    Type:       as.OutgoingPayment,
    Actions:    []as.AccessOutgoingActions{as.AccessOutgoingActionsCreate},
    Identifier: *customerWalletAddress.Id,
    Limits:     &limits,
  }
  outgoingAccessItem := as.AccessItem{}
  if err := outgoingAccessItem.FromAccessOutgoing(outgoingAccess); err != nil {
    log.Fatalf("Error creating AccessItem: %v\n", err)
  }
  outgoingAccessToken := struct {
    Access as.Access `json:"access"`
  }{
    Access: []as.AccessItem{outgoingAccessItem},
  }
  interact := &as.InteractRequest{
    Start: []as.InteractRequestStart{as.InteractRequestStartRedirect},
    Finish: &as.InteractRequestFinish{
      Method: as.Redirect,
      Uri:    "https://paymentplatform.example/finish/{...}", // where to redirect the customer after they've completed interaction
      Nonce:  NONCE,
    },
  }
  pendingCustomerOutgoingPaymentGrant, err := client.Grant.Request(context.TODO(), op.GrantRequestParams{
    URL: *customerWalletAddress.AuthServer,
    RequestBody: as.GrantRequestWithAccessToken{
      AccessToken: outgoingAccessToken,
      Interact:    interact,
    },
  })
  if err != nil {
    log.Fatalf("Error requesting outgoing payment grant: %v\n", err)
  }
  ```
  </TabItem>
</Tabs>

### 7. Comenzar la interacción con el consumidor

<StartInteraction />

### 8. Finalizar la interacción con el consumidor

<FinishInteraction />

### 9. Solicitar una continuación de la concesión de autorización

En nuestro ejemplo, suponemos que el IdP con el que interactuó el consumidor cuenta con una interfaz de usuario. Cuando la interacción finaliza, el consumidor regresa a su plataforma. Ahora la plataforma puede realizar una solicitud de continuación de la concesión de pago saliente.

:::note
En una situación hipotética donde una interfaz de usuario no se encuentra disponible, analice la posibilidad de implementar un mecanismo de sondeo para verificar que se haya completado la interacción.
:::

Llame a la <Badge text="POST" variant="success" /> [Grant Continuation Request API](/es/apis/auth-server/operations/post-continue). El propósito de esta llamada consiste en solicitar un token de acceso que permita a su plataforma solicitar la creación de recursos de pago saliente en la cuenta de la billetera del consumidor.

Emita la solicitud al `continue uri` proporcionado en la respuesta de concesión de pago saliente inicial (paso 6). Por ejemplo:

`POST https://auth.cloudninebank.example.com/continue/4CF492MLVMSW9MKMXKHQ`

Incluya la `interact_ref` devuelta en los parámetros de consulta del URI de redirección.

<Tabs syncKey="lang">
<TabItem label='TypeScript/JavaScript' icon='seti:javascript'>
  ```ts wrap
  const customerOutgoingPaymentGrant = await client.grant.continue(
    {
      url: pendingCustomerOutgoingPaymentGrant.continue.uri,
      accessToken: pendingCustomerOutgoingPaymentGrant.continue.access_token.value
    },
    {
      interact_ref: interactRef
    }
  )
  ```
</TabItem>
<TabItem label='Rust' icon='seti:rust'>
 ```rust wrap
 let customer_outgoing_payment_grant = client
   .grant()
   .continue_grant(
     if let Some(continue_field) = &pending_customer_outgoing_payment_grant.continue_field { &continue_field.uri } else { eprintln!("Missing continue field on pending grant"); return Ok(()); },
     &interact_ref,
     if let Some(continue_field) = &pending_customer_outgoing_payment_grant.continue_field { Some(&continue_field.access_token.value) } else { None },
   )
   .await?;
 ```
 </TabItem>

 <TabItem label='Go' icon='seti:go'>

  ```go wrap
  customerOutgoingPaymentGrant, err := client.Grant.Continue(context.TODO(), op.GrantContinueParams{
    URL:         pendingCustomerOutgoingPaymentGrant.Continue.Uri,
    AccessToken: pendingCustomerOutgoingPaymentGrant.Continue.AccessToken.Value,
    InteractRef: INTERACT_REF
  })
  if err != nil {
    log.Fatalf("Error continuing grant: %v\n", err)
  }
  ```
  </TabItem>
</Tabs>

### 10. Solicitar la creación de recursos de pagos salientes

Recuerde que las respuestas de la Create Quote API para el comerciante y para su plataforma (paso 5) incluían un `debitAmount` y un `receiveAmount`. Las respuestas también incluían una `id`, que es una URL para identificar cada cotización.

Dado que las cotizaciones contienen los montos por debitar y recibir, no especificaremos otros montos al realizar una solicitud a la Create Outgoing Payment API. En su lugar, especificaremos un `quoteId`.

Utilice los tókenes de acceso devueltos en el paso 5 para llamar a la <Badge text="POST" variant="success" /> [Create an Outgoing Payment API](/es/apis/resource-server/operations/create-outgoing-payment).

El propósito de estas llamadas consiste en solicitar la creación de un recurso de pago saliente en la cuenta de la billetera del consumidor: uno para el comerciante y otro para su plataforma. Incluya el `quoteId` correspondiente en cada solicitud.

<Tabs syncKey="lang">
<TabItem label='TypeScript/JavaScript' icon='seti:javascript'>
  ```ts wrap
  // Merchant
  const customerOutgoingPaymentToMerchant = await client.outgoingPayment.create(
    {
      url: customerWalletAddress.resourceServer,
      accessToken: customerOutgoingPaymentGrant.access_token.value
    },
    {
      walletAddress: customerWalletAddress.id,
      quoteId: merchantQuote.id
    }
  )
  // Platform
  const customerOutgoingPaymentToPlatform = await client.outgoingPayment.create(
    {
      url: customerWalletAddress.resourceServer,
      accessToken: customerOutgoingPaymentGrant.access_token.value
    },
    {
      walletAddress: customerWalletAddress.id,
      quoteId: platformQuote.id
    }
  )
```
 </TabItem>
<TabItem label='Rust' icon='seti:rust'>
 ```rust wrap
 use open_payments::types::OutgoingPaymentRequest;
 let merchant_outgoing_request = OutgoingPaymentRequest {
   wallet_address: customer_wallet_address.id.clone(),
   receiver: Some(merchant_incoming_payment.id.clone()),
   debit_amount: None,
   receive_amount: None,
   quote_id: Some(merchant_quote.id.clone()),
 };
 let platform_outgoing_request = OutgoingPaymentRequest {
   wallet_address: customer_wallet_address.id.clone(),
   receiver: Some(platform_incoming_payment.id.clone()),
   debit_amount: None,
   receive_amount: None,
   quote_id: Some(platform_quote.id.clone()),
 };
 let customer_outgoing_payment_to_merchant = client
   .outgoing_payments()
   .create(&customer_wallet_address.resource_server, &merchant_outgoing_request, Some(&customer_outgoing_payment_grant.access_token.value))
   .await?;
 let customer_outgoing_payment_to_platform = client
   .outgoing_payments()
   .create(&customer_wallet_address.resource_server, &platform_outgoing_request, Some(&customer_outgoing_payment_grant.access_token.value))
   .await?;
 ```
 </TabItem>

  <TabItem label='Go' icon='seti:go'>

  ```go wrap
  // Merchant
  var merchantOutgoingPayload rs.CreateOutgoingPaymentRequest
  if err := merchantOutgoingPayload.FromCreateOutgoingPaymentWithQuote(rs.CreateOutgoingPaymentWithQuote{
    WalletAddressSchema: *customerWalletAddress.Id,
    QuoteId:             *merchantQuote.Id,
  }); err != nil {
    log.Fatalf("Error creating merchant payload: %v\n", err)
  }
  customerOutgoingPaymentToMerchant, err := client.OutgoingPayment.Create(context.TODO(), op.OutgoingPaymentCreateParams{
    BaseURL:     *customerWalletAddress.ResourceServer,
    AccessToken: customerOutgoingPaymentGrant.AccessToken.Value,
    Payload:     merchantOutgoingPayload,
  })
  if err != nil {
    log.Fatalf("Error creating outgoing payment to merchant: %v\n", err)
  }
  // Platform
  var platformOutgoingPayload rs.CreateOutgoingPaymentRequest
  if err := platformOutgoingPayload.FromCreateOutgoingPaymentWithQuote(rs.CreateOutgoingPaymentWithQuote{
    WalletAddressSchema: *customerWalletAddress.Id,
    QuoteId:             *platformQuote.Id,
  }); err != nil {
    log.Fatalf("Error creating platform payload: %v\n", err)
  }
  customerOutgoingPaymentToPlatform, err := client.OutgoingPayment.Create(context.TODO(), op.OutgoingPaymentCreateParams{
    BaseURL:     *customerWalletAddress.ResourceServer,
    AccessToken: customerOutgoingPaymentGrant.AccessToken.Value,
    Payload:     platformOutgoingPayload,
  })
  if err != nil {
    log.Fatalf("Error creating outgoing payment to platform: %v\n", err)
  }
  ```
  </TabItem>
</Tabs>

<details>
<summary>Ejemplo de respuesta</summary>
El siguiente ejemplo muestra una respuesta cuando se crea un recurso de pago saliente en la cuenta del consumidor para el comerciante. Se devolverá una respuesta similar cuando se cree un recurso de pago saliente para usted, como proveedor de billetera.

```json wrap
{
  "id": "https://cloudninebank.example.com/outgoing-payments/{...}", // url identifying the outgoing payment
  "walletAddress": "https://cloudninebank.example.com/customer",
  "receiver": "https://happylifebank.example.com/incoming-payments/{...}", // url of the incoming payment being paid
  "debitAmount": {
    "value": "9900",
    "assetCode": "USD",
    "assetScale": 2
  },
  "receiveAmount": {
    "value": "9900",
    "assetCode": "USD",
    "assetScale": 2
  },
  "sentAmount": {
    "value": "0",
    "assetCode": "USD",
    "assetScale": 2
  },
  "createdAt": "2022-03-12T23:20:54.52Z"
}
```

</details>
````

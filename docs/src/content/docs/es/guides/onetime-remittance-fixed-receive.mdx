---
title: Enviar una remesa con un monto de recepción fijo
---

import { LinkOut } from '@interledger/docs-design-system'
import { Tabs, TabItem, Badge } from '@astrojs/starlight/components'
import Start from '/src/partials/es/grant-start-interaction.mdx'
import Finish from '/src/partials/es/grant-finish-interaction.mdx'

:::tip[Resumen]
Aprenda cómo enviar un pago de remesa único en el que el destinatario recibirá un monto fijo.
:::

Un pago de remesa es una transferencia de dinero de una persona a otra, normalmente entre países o a larga distancia, que a menudo implica una conversión de monedas. En esta guía, aprenderá cómo implementar una funcionalidad de pago único de remesa en la que su usuario pueda especificar exactamente cuánto debe recibir el destinatario.

Este enfoque es útil en particular para situaciones de aplicaciones de remesas en estos casos:

- El remitente y el destinatario efectúan operaciones, cada uno, en monedas distintas.
- El remitente busca que el destinatario reciba un monto fijo expresado en la moneda local del destinatario.
- El emisor está dispuesto a asumir cualquier diferencia generada por el tipo de cambio.

## Caso hipotético

Imagine que alguien en EE. UU. quiere enviar dinero a un familiar en México. Esta persona quiere que su familiar reciba exactamente 5000 pesos mexicanos (MXN), independientemente de cuál sea la conversión de monedas. Esto difiere de un pago en el que el remitente especifica exactamente cuánto enviar, y el monto que el destinatario recibe puede variar con el tipo de cambio.

Para esta guía, asumirá el papel de un desarrollador que está creando una aplicación de remesas. La guía explica la forma de enviar un pago en USD, en la que el destinatario recibe exactamente MXN 5000.

**Detalles de la transacción de ejemplo:**

- **El destinatario recibe**: MXN 5000 (el monto exacto)
- **Conversión de moneda**: USD a MXN a un tipo de cambio de 18,00
- **El remitente envía**: USD \$277,78 ($5000/18,00)

Las tres partes que intervienen en este caso son las siguientes:

- **Desarrollador**: usted, la persona que construye la aplicación de remesas.
- **Remitente**: la persona que utiliza su aplicación para enviar dinero en USD.
- **Destinatario**: la persona que recibe el dinero en MXN.

## Puntos finales

- <Badge text="GET" variant="note" />
  <LinkOut href="https://openpayments.dev/apis/wallet-address-server/operations/get-wallet-address/">
    Get Wallet Address
  </LinkOut>
- <Badge text="POST" variant="success" />
  <LinkOut href="https://openpayments.dev/apis/auth-server/operations/post-request/">
    Grant Request
  </LinkOut>
- <Badge text="POST" variant="success" />
  <LinkOut href="https://openpayments.dev/apis/resource-server/operations/create-incoming-payment/">
    Create Incoming Payment
  </LinkOut>
- <Badge text="POST" variant="success" />
  <LinkOut href="https://openpayments.dev/apis/resource-server/operations/create-quote/">
    Create a Quote
  </LinkOut>
- <Badge text="POST" variant="success" />
  <LinkOut href="https://openpayments.dev/apis/auth-server/operations/post-continue/">
    Grant Continuation Request
  </LinkOut>
- <Badge text="POST" variant="success" />
  <LinkOut href="https://openpayments.dev/apis/resource-server/operations/create-outgoing-payment/">
    Create an Outgoing Payment
  </LinkOut>

## Pasos

### 1. Obtener los datos de la dirección de billetera

Cuando el remitente inicia el pago de la remesa, su aplicación necesita obtener la información de la dirección de billetera tanto del remitente como del destinatario.

Asumamos que el remitente ya ha proporcionado su propia dirección de billetera cuando se registró en su aplicación. Asumamos también que el remitente ingresó la dirección de billetera del destinatario en el formulario de pago de su aplicación.

Llame a la <Badge text="GET" variant="note" /> [Get Wallet Address API](/apis/wallet-address-server/operations/get-wallet-address) para cada dirección.

<Tabs syncKey="lang">
  <TabItem label='TypeScript/JavaScript' icon='seti:javascript'>
  ```ts wrap
  const senderWalletAddress = await client.walletAddress.get({
    url: 'https://cloudninebank.example.com/sender'
  })
  const recipientWalletAddress = await client.walletAddress.get({
    url: 'https://happylifebank.example.com/recipient'
  })
  ```
  </TabItem>
  <TabItem label='Rust' icon='seti:rust'>
  ```rust wrap
  let sender_wallet_address = client.wallet_address().get("https://cloudninebank.example.com/sender").await?;
  let recipient_wallet_address = client.wallet_address().get("https://happylifebank.example.com/recipient").await?;
  ```
  </TabItem>

  <TabItem label='PHP' icon='seti:php'>

```php wrap
$senderWalletAddress = $client->walletAddress()->get([
  'url' => 'https://cloudninebank.example.com/sender'
]);
$recipientWalletAddress = $client->walletAddress()->get([
  'url' => 'https://happylifebank.example.com/recipient'
]);
```

  </TabItem>

  <TabItem label='Go' icon='seti:go'>

```go wrap
  senderWalletAddress, err := client.WalletAddress.Get(context.TODO(), op.WalletAddressGetParams{
    URL: "https://cloudninebank.example.com/sender",
  })
  if err != nil {
    log.Fatalf("Error fetching sender wallet address: %v\n", err)
  }

  recipientWalletAddress, err := client.WalletAddress.Get(context.TODO(), op.WalletAddressGetParams{
    URL: "https://happylifebank.example.com/recipient",
  })
  if err != nil {
    log.Fatalf("Error fetching recipient wallet address: %v\n", err)
  }
```

  </TabItem>
</Tabs>

<details>
<summary>Respuestas de ejemplo</summary>
El siguiente ejemplo muestra una respuesta del proveedor de billetera del remitente.

```json wrap
{
  "id": "https://cloudninebank.example.com/sender",
  "assetCode": "USD",
  "assetScale": 2,
  "authServer": "https://auth.cloudninebank.example.com/",
  "resourceServer": "https://cloudninebank.example.com/op"
}
```

El siguiente ejemplo muestra una respuesta del proveedor de billetera del destinatario.

```json wrap
{
  "id": "https://happylifebank.example.com/recipient",
  "assetCode": "MXN",
  "assetScale": 2,
  "authServer": "https://auth.happylifebank.example.com/",
  "resourceServer": "https://happylifebank.example.com/op"
}
```

</details>

### 2. Solicitar una concesión de autorización para un pago entrante

Utilice los datos del destinatario `authServer`, recibidos en el paso anterior, para llamar a la <Badge text="POST" variant="success" /> [Grant Request API](/apis/auth-server/operations/post-request/).

Esta llamada obtiene un token de acceso que permite a su aplicación solicitar la creación de un recurso de pago entrante en la cuenta de billetera del destinatario.

<Tabs syncKey="lang">
  <TabItem label='TypeScript/JavaScript' icon='seti:javascript'>
  ```ts wrap
  const recipientIncomingPaymentGrant = await client.grant.request(
    {
      url: recipientWalletAddress.authServer
    },
    {
      access_token: {
        access: [
          {
            type: 'incoming-payment',
            actions: ['create']
          },
        ],
      },
    },
  );
  ```
  </TabItem>
  <TabItem label='Rust' icon='seti:rust'>
  ```rust wrap
  use open_payments::types::{AccessTokenRequest, AccessItem, IncomingPaymentAction, GrantRequest};

let incoming_access = AccessTokenRequest {
access: vec![AccessItem::IncomingPayment { actions: vec![IncomingPaymentAction::Create, IncomingPaymentAction::Complete], identifier: None }],
};
let incoming_grant_request = GrantRequest::new(incoming_access, None);
let recipient_incoming_payment_grant = client
.grant()
.request(&recipient_wallet_address.auth_server, &incoming_grant_request)
.await?;

````
  </TabItem>

  <TabItem label='PHP' icon='seti:php'>

```php wrap
$recipientIncomingPaymentGrant = $client->grant()->request(
  [
    'url' => $recipientWalletAddress->authServer
  ],
  [
    'access_token' => [
      'access' => [
        [
          'type' => 'incoming-payment',
          'actions' => ['create']
        ],
      ],
    ],
  ]
);
  ```

  </TabItem>

  <TabItem label='Go' icon='seti:go'>

  ```go wrap
    incomingAccess := as.AccessIncoming{
      Type:    as.IncomingPayment,
      Actions: []as.AccessIncomingActions{as.AccessIncomingActionsCreate},
    }
    accessItem := as.AccessItem{}
    if err := accessItem.FromAccessIncoming(incomingAccess); err != nil {
      log.Fatalf("Error creating AccessItem: %v\n", err)
    }
    accessToken := struct {
      Access as.Access `json:"access"`
    }{
      Access: []as.AccessItem{accessItem},
    }

    recipientIncomingPaymentGrant, err := client.Grant.Request(context.TODO(), op.GrantRequestParams{
      URL:         *recipientWalletAddress.AuthServer,
      RequestBody: as.GrantRequestWithAccessToken{AccessToken: accessToken},
    })
    if err != nil {
      log.Fatalf("Error requesting incoming payment grant: %v\n", err)
    }
  ```

  </TabItem>
</Tabs>

<details>
<summary>Ejemplo de respuesta</summary>
El siguiente ejemplo muestra una respuesta del proveedor de billetera del destinatario.
```json wrap
{
  "access_token": {
    "value": "...", // access token value for incoming payment grant
    "manage": "https://auth.happylifebank.example.com/token/{...}", // management uri for access token
    "access": [
      {
        "type": "incoming-payment",
        "actions": ["create"]
      }
    ]
  },
  "continue": {
    "access_token": {
      "value": "..." // access token for continuing the request
    },
    "uri": "https://auth.happylifebank.example.com/continue/{...}" // continuation request uri
  }
}
```
</details>

### 3. Solicitar la creación de un recurso de pago entrante

Use el token de acceso devuelto en la respuesta anterior para llamar a la <Badge text="POST" variant="success" /> [Create Incoming Payment API](/apis/resource-server/operations/create-incoming-payment).

Esta llamada solicita la creación de un recurso de pago entrante en la cuenta de billetera del destinatario.

<Tabs syncKey="lang">
  <TabItem label='TypeScript/JavaScript' icon='seti:javascript'>
  ```ts wrap
  const recipientIncomingPayment = await client.incomingPayment.create(
    {
      url: recipientWalletAddress.resourceServer,
      accessToken: recipientIncomingPaymentGrant.access_token.value
    },
    {
      walletAddress: recipientWalletAddress.id,
    },
  )
  ```
  </TabItem>
  <TabItem label='Rust' icon='seti:rust'>
  ```rust wrap
  use open_payments::types::IncomingPaymentRequest;

let incoming_request = IncomingPaymentRequest {
wallet_address: recipient_wallet_address.id.clone(),
incoming_amount: None,
expires_at: None,
metadata: None,
};
let recipient_incoming_payment = client
.incoming_payments()
.create(
&recipient_wallet_address.resource_server,
&incoming_request,
Some(&recipient_incoming_payment_grant.access_token.value),
)
.await?;

````

</TabItem>

  <TabItem label='PHP' icon='seti:php'>

```php wrap
$recipientIncomingPayment = $client->incomingPayment()->create(
  [
    'url' => $recipientWalletAddress->resourceServer,
    'accessToken' => $recipientIncomingPaymentGrant->access_token->value
  ],
  [
    'walletAddress' => $recipientWalletAddress->id,
  ]
);
```

  </TabItem>

  <TabItem label='Go' icon='seti:go'>

```go wrap
  recipientIncomingPayment, err := client.IncomingPayment.Create(context.TODO(), op.IncomingPaymentCreateParams{
    BaseURL:     *recipientWalletAddress.ResourceServer,
    AccessToken: recipientIncomingPaymentGrant.AccessToken.Value,
    Payload: rs.CreateIncomingPaymentJSONBody{
      WalletAddressSchema: *recipientWalletAddress.Id,
    },
  })
  if err != nil {
    log.Fatalf("Error creating incoming payment: %v\n", err)
  }
```

  </TabItem>
</Tabs>

<details>
<summary>Ejemplo de respuesta</summary>
El siguiente ejemplo muestra una respuesta del proveedor de billetera del destinatario.
```json wrap
{
  "id": "https://happylifebank.example.com/incoming-payments/{...}",
  "walletAddress": "https://happylifebank.example.com/recipient",
  "receivedAmount": {
    "value": "0",
    "assetCode": "MXN",
    "assetScale": 2
  },
  "completed": false,
  "createdAt": "2025-03-12T23:20:50.52Z",
  "methods": [
    {
      "type": "ilp",
      "ilpAddress": "...",
      "sharedSecret": "..."
    }
  ]
}
```
</details>

### 4. Solicitar una concesión de autorización para una cotización

Utilice los datos del remitente `authServer` recibidos en el paso 1 para llamar a la <Badge text="POST" variant="success" /> [Grant Request API](/apis/auth-server/operations/post-request/).

Esta llamada obtiene un token de acceso que permite a su aplicación solicitar la creación de un recurso de cotización en la cuenta de billetera del remitente.

<Tabs syncKey="lang">
  <TabItem label='TypeScript/JavaScript' icon='seti:javascript'>
  ```ts wrap
  const senderQuoteGrant = await client.grant.request(
    {
      url: senderWalletAddress.authServer
    },
    {
      access_token: {
        access: [
          {
            type: 'quote',
            actions: ['create']
          }
        ]
      }
    }
  )
  ```
  </TabItem>
  <TabItem label='Rust' icon='seti:rust'>
  ```rust wrap
  use open_payments::types::{
    AccessTokenRequest,
    AccessItem,
    QuoteAction,
    GrantRequest,
  };

let quote_access = AccessTokenRequest {
access: vec![AccessItem::Quote { actions: vec![QuoteAction::Create] }],
};
let quote_grant_request = GrantRequest::new(quote_access, None);
let sender_quote_grant = client
.grant()
.request(&sender_wallet_address.auth_server, &quote_grant_request)
.await?;

````
</TabItem>

<TabItem label='PHP' icon='seti:php'>
```php wrap
  $senderQuoteGrant = $client->grant()->request(
    [
      'url' => $senderWalletAddress->authServer
    ],
    [
      'access_token' => [
        'access' => [
          [
            'type' => 'quote',
            'actions' => ['create']
          ]
        ]
      ]
    ]
  );
  ```

</TabItem>

<TabItem label='Go' icon='seti:go'>

```go wrap
quoteAccess := as.AccessQuote{
  Type:    as.Quote,
  Actions: []as.AccessQuoteActions{as.Create},
}
quoteAccessItem := as.AccessItem{}
if err := quoteAccessItem.FromAccessQuote(quoteAccess); err != nil {
  log.Fatalf("Error creating AccessItem: %v\n", err)
}
quoteAccessToken := struct {
  Access as.Access `json:"access"`
}{
  Access: []as.AccessItem{quoteAccessItem},
}

senderQuoteGrant, err := client.Grant.Request(context.TODO(), op.GrantRequestParams{
  URL: senderWalletAddress.AuthServer,
  RequestBody: as.GrantRequestWithAccessToken{AccessToken: quoteAccessToken},
})
if err != nil {
  log.Fatalf("Error requesting quote grant: %v\n", err)
}
```

  </TabItem>
</Tabs>

<details>
<summary>Ejemplo de respuesta</summary>
El siguiente ejemplo muestra una respuesta del proveedor de billetera del remitente.
```json wrap
{
  "access_token": {
    "value": "...", // access token value for quote grant
    "manage": "https://auth.cloudninebank.example.com/token/{...}", // management uri for access token
    "access": [
      {
        "type": "quote",
        "actions": ["create"]
      }
    ]
  },
  "continue": {
    "access_token": {
      "value": "..." // access token for continuing the request
    },
  "uri": "https://auth.cloudninebank.example.com/continue/{...}" // continuation request uri
  }
}

```

</details>

### 5. Solicitar la creación de un recurso de cotización

Utilice el token de acceso recibido en el paso anterior para llamar a la <Badge text="POST" variant="success" /> [Create Quote API](/apis/resource-server/operations/create-quote/).

Esta llamada solicita la creación de un recurso de cotización en la cuenta de la billetera del remitente. La solicitud debe contener el `receiver`, que es la `id` de pago entrante del destinatario, junto con el `receiveAmount`, que es el monto exacto que el remitente quiere que reciba el destinatario.

El `receiveAmount` especifica que el destinatario recibirá exactamente MXN 5000.

<Tabs syncKey="lang">
  <TabItem label='TypeScript/JavaScript' icon='seti:javascript'>
  ```ts wrap
  const senderQuote = await client.quote.create(
    {
      url: senderWalletAddress.resourceServer,
      accessToken: senderQuoteGrant.access_token.value
    },
    {
      method: 'ilp',
      walletAddress: senderWalletAddress.id,
      receiver: recipientIncomingPayment.id,
      receiveAmount: {
        value: '500000',
        assetCode: 'MXN',
        assetScale: 2
      }
    }
  )
```

  </TabItem>
  <TabItem label='Rust' icon='seti:rust'>
  ```rust wrap
  use open_payments::types::{QuoteRequest, QuoteMethod, Amount};

let quote_request = QuoteRequest {
method: QuoteMethod::Ilp,
wallet_address: Some(sender_wallet_address.id.clone()),
receiver: Some(recipient_incoming_payment.id.clone()),
debit_amount: None,
receive_amount: Some(Amount { value: "500000".into(), asset_code: "MXN".into(), asset_scale: 2 }),
};
let sender_quote = client
.quotes()
.create(
&sender_wallet_address.resource_server,
&quote_request,
Some(&sender_quote_grant.access_token.value),
)
.await?;

```

</TabItem>

<TabItem label='PHP' icon='seti:php'>

```php wrap
$senderQuote = $client->quote()->create(
  [
    'url' => $senderWalletAddress->resourceServer,
    'accessToken' => $senderQuoteGrant->access_token->value
  ],
  [
    'method' => 'ilp',
    'walletAddress' => $senderWalletAddress->id,
    'receiver' => $recipientIncomingPayment->id,
    'receiveAmount' => [
      'value' => '500000',
      'assetCode' => 'MXN',
      'assetScale' => 2
    ]
  ]
);
```

</TabItem>

<TabItem label='Go' icon='seti:go'>

```go wrap
  senderQuote, err := client.Quote.Create(context.TODO(), op.QuoteCreateParams{
  	BaseURL:     *senderWalletAddress.ResourceServer,
  	AccessToken: senderQuoteGrant.AccessToken.Value,
  	Payload: rs.CreateQuoteJSONBody2{
  		WalletAddressSchema: *senderWalletAddress.Id,
  		Receiver:            *recipientIncomingPayment.Id,
  		Method:              "ilp",
  		ReceiveAmount: rs.Amount{
  			Value:      "500000",
  			AssetCode:  "MXN",
  			AssetScale: 2,
  		},
  	},
  })
  if err != nil {
  	log.Fatalf("Error creating quote: %v\n", err)
  }
```

  </TabItem>
</Tabs>

La respuesta devuelve un `receiveAmount`, un `debitAmount` y demás información requerida.

- `debitAmount`: el monto que el remitente debe pagar (en USD en nuestro ejemplo) después de la conversión de moneda.
- `receiveAmount`: el monto que el destinatario recibirá realmente (exactamente MXN 5000 en nuestro ejemplo).

Usted usará este mismo `receiveAmount` en el paso siguiente al solicitar la concesión de autorización del pago saliente, de modo que el remitente autorice este monto exacto.

:::note[Cotizaciones con vencimiento]
Las cotizaciones incluyen una marca de tiempo `expiresAt`. Cree el pago saliente antes de que la cotización expire. Si la creación falla porque la cotización expiró, solicite una nueva e intente otra vez.
:::

<details>
<summary>Ejemplo de respuesta</summary>
El siguiente ejemplo muestra una respuesta del proveedor de billetera del remitente.
```json wrap
{
  "id": "https://cloudninebank.example.com/quotes/{...}", // url identifying the quote
  "walletAddress": "https://cloudninebank.example.com/sender",
  "receiver": "https://happylifebank.example.com/incoming-payments/{...}", // url of the incoming payment the quote is created for
  "debitAmount": {
    "value": "27778", // Sender pays $277.78 USD after currency conversion
    "assetCode": "USD",
    "assetScale": 2
  },
  "receiveAmount": {
    "value": "500000", // Recipient receives $5,000 MXN
    "assetCode": "MXN",
    "assetScale": 2
  },
  "method": "ilp",
  "createdAt": "2025-03-12T23:22:51.50Z",
  "expiresAt": "2025-03-12T23:24:51.50Z"
}
```
</details>

### 6. Solicitar una concesión de autorización interactiva para un pago saliente

Utilice la información del remitente `authServer` recibida en el paso 1 para llamar a la <Badge text="POST" variant="success" /> [Grant Request API](/apis/auth-server/operations/post-request).

Esta llamada obtiene un token de acceso que permite a su aplicación solicitar la creación de un recurso de pago saliente en la cuenta de billetera del remitente.

Para asegurar que el remitente autorice el monto correcto, incluya el `receiveAmount` en el objeto `limits`. Esto limita el pago saliente al monto de recepción especificado y mantiene la concesión de autorización alineada con la cotización del paso anterior.

:::note
Los pagos salientes requieren una concesión de autorización interactiva. Este tipo de concesión de autorización obtendrá el consentimiento del remitente antes de que se realice un pago saliente desde su cuenta de billetera. Puede encontrar más información en las páginas del [flujo de Open Payments](/concepts/op-flow/#outgoing-payment) y [proveedores de identidad](/identity/idp).
:::

<Tabs syncKey="lang">
  <TabItem label='TypeScript/JavaScript' icon='seti:javascript'>
  ```ts wrap
  const pendingSenderOutgoingPaymentGrant = await client.grant.request(
  {
    url: senderWalletAddress.authServer
  },
  {
    access_token: {
      access: [
        {
          identifier: senderWalletAddress.id,
          type: 'outgoing-payment',
          actions: ['create'],
          limits: {
            receiveAmount: {
              assetCode: 'MXN',
              assetScale: 2,
              value: '500000'
            }
          }
        }
      ]
    },
    interact: {
      start: ['redirect'],
      finish: {
        method: 'redirect',
        uri: 'https://myapp.example.com/finish/{...}', // where to redirect your user after they've completed the interaction
        nonce: NONCE
      }
    }
  }
)
  ```
  </TabItem>
  <TabItem label='Rust' icon='seti:rust'>
  ```rust wrap
  use open_payments::types::{
    AccessTokenRequest,
    AccessItem,
    OutgoingPaymentAction,
    InteractRequest,
    InteractStart,
    InteractFinish,
    InteractFinishMethod,
    AccessLimits,
    Amount,
    GrantRequest,
  };

let outgoing_access = AccessTokenRequest {
access: vec![AccessItem::OutgoingPayment {
identifier: Some(sender_wallet_address.id.clone()),
actions: vec![OutgoingPaymentAction::Create],
limits: Some(AccessLimits {
receive_amount: Some(Amount { value: "500000".into(), asset_code: "MXN".into(), asset_scale: 2 }),
..Default::default()
}),
}],
};
let interact = InteractRequest {
start: Some(vec![InteractStart::Redirect]),
finish: Some(InteractFinish {
method: InteractFinishMethod::Redirect,
uri: Some("https://myapp.example.com/finish/{...}".into()),
nonce: Some("NONCE".into()),
}),
};
let outgoing_grant_request = GrantRequest::new(outgoing_access, Some(interact));
let pending_sender_outgoing_payment_grant = client
.grant()
.request(&sender_wallet_address.auth_server, &outgoing_grant_request)
.await?;

```

</TabItem>

<TabItem label='PHP' icon='seti:php'>

```php wrap
$pendingSenderOutgoingPaymentGrant = $client->grant()->request(
  [
    'url' => $senderWalletAddress->authServer
  ],
  [
    'access_token' => [
      'access' => [
        [
          'identifier' => $senderWalletAddress->id,
          'type' => 'outgoing-payment',
          'actions' => ['create'],
          'limits' => [
            'receiveAmount' => [
              'assetCode' => 'MXN',
              'assetScale' => 2,
              'value' => '500000'
            ]
          ]
        ]
      ]
    ],
    'interact' => [
      'start' => ['redirect'],
      'finish' => [
        'method' => 'redirect',
        'uri' => 'https://myapp.example.com/finish/{...}', // where to redirect your user after they've completed the interaction
        'nonce' => 'NONCE'
      ]
    ]
  ]
);
```

</TabItem>

  <TabItem label='Go' icon='seti:go'>

```go wrap
  outgoingAccess := as.AccessOutgoing{
  	Type:       as.OutgoingPayment,
  	Actions:    []as.AccessOutgoingActions{as.AccessOutgoingActionsCreate},
  	Identifier: *senderWalletAddress.Id,
  	Limits: &as.LimitsOutgoing{
  		ReceiveAmount: &as.Amount{
  			Value:      "500000",
  			AssetCode:  "MXN",
  			AssetScale: 2,
  		},
  	},
  }
  outgoingAccessItem := as.AccessItem{}
  if err := outgoingAccessItem.FromAccessOutgoing(outgoingAccess); err != nil {
  	log.Fatalf("Error creating AccessItem: %v\n", err)
  }
  outgoingAccessToken := struct {
  	Access as.Access `json:"access"`
  }{
  	Access: []as.AccessItem{outgoingAccessItem},
  }
  interact := &as.InteractRequest{
  	Start: []as.InteractRequestStart{as.InteractRequestStartRedirect},
  	Finish: &as.InteractRequestFinish{
  		Method: as.Redirect,
  		Uri:    "https://myapp.example.com/finish/{...}",
  		Nonce:  NONCE,
  	},
  }

  pendingSenderOutgoingPaymentGrant, err := client.Grant.Request(context.TODO(), op.GrantRequestParams{
  	URL: *senderWalletAddress.AuthServer,
  	RequestBody: as.GrantRequestWithAccessToken{
  		AccessToken: outgoingAccessToken,
  		Interact:    interact,
  	},
  })
  if err != nil {
  	log.Fatalf("Error requesting outgoing payment grant: %v\n", err)
  }
```

  </TabItem>
</Tabs>

<details>
<summary>Ejemplo de respuesta</summary>
El siguiente ejemplo muestra una respuesta del proveedor de billetera del remitente.
```json wrap
{
  "interact": {
    "redirect": "https://auth.cloudninebank.example.com/{...}", // uri to redirect the customer to, to begin interaction
    "finish": "..." // unique key to secure the callback
  },
  "continue": {
    "access_token": {
      "value": "..." // access token for continuing the outgoing payment grant request
    },
    "uri": "https://auth.cloudninebank.example.com/continue/{...}", // uri for continuing the outgoing payment grant request
    "wait": 30
  }
}
```
</details>

### 7. Comenzar la interacción con el consumidor

<Start />

### 8. Finalizar la interacción con el consumidor

<Finish />

### 9. Solicitar una continuación de la concesión de autorización

En nuestro ejemplo, suponemos que el IdP con el que interactuó su usuario cuenta con una interfaz de usuario. Cuando la interacción finaliza, el usuario regresa a su aplicación. Ahora su aplicación puede realizar una solicitud de continuación de la concesión de autorización de pago saliente.

:::note
En una situación hipotética donde una interfaz de usuario no se encuentra disponible, analice la posibilidad de implementar un mecanismo de sondeo para verificar que se haya completado la interacción.
:::

Llame a la <Badge text="POST" variant="success" /> [Grant Continuation Request API](/apis/auth-server/operations/post-continue/). Esta llamada solicita un token de acceso que permite a su aplicación solicitar la creación de un recurso de pago saliente en la cuenta de billetera del remitente.

Emita la solicitud al `continue.uri` proporcionado en la respuesta de concesión de autorización de pago saliente inicial (paso 6).

Incluya la `interact_ref` devuelta en los parámetros de consulta del URI de redirección.

<Tabs syncKey="lang">
  <TabItem label='TypeScript/JavaScript' icon='seti:javascript'>
  ```ts wrap
  const senderOutgoingPaymentGrant = await client.grant.continue(
    {
      url: pendingSenderOutgoingPaymentGrant.continue.uri,
      accessToken: pendingSenderOutgoingPaymentGrant.continue.access_token.value
    },
    {
      interact_ref: interactRef
    }
  )
  ```
  </TabItem>
  <TabItem label='Rust' icon='seti:rust'>
  ```rust wrap
  let continue_field = match &pending_sender_outgoing_payment_grant.continue_field {
    Some(c) => c,
    None => {
      eprintln!("Missing continue field on pending grant");
      return Ok(());
    }
  };
  let sender_outgoing_payment_grant = client
    .grant()
    .continue_grant(
      &continue_field.uri,
      &interact_ref,
      Some(&continue_field.access_token.value),
    )
    .await?;
  ```
  </TabItem>

  <TabItem label='PHP' icon='seti:php'>

```php wrap
$senderOutgoingPaymentGrant = $client->grant()->continue(
  [
    'url' => $pendingSenderOutgoingPaymentGrant->continue->uri,
    'accessToken' => $pendingSenderOutgoingPaymentGrant->continue->access_token->value
  ],
  [
    'interact_ref' => $interactRef
  ]
);
```

  </TabItem>

  <TabItem label='Go' icon='seti:go'>

```go wrap
  senderOutgoingPaymentGrant, err := client.Grant.Continue(context.TODO(), op.GrantContinueParams{
    URL:         pendingSenderOutgoingPaymentGrant.Continue.Uri,
    AccessToken: pendingSenderOutgoingPaymentGrant.Continue.AccessToken.Value,
    InteractRef: INTERACT_REF,
  })
  if err != nil {
    log.Fatalf("Error continuing grant: %v\n", err)
  }
```

  </TabItem>
</Tabs>

<details>
<summary>Ejemplo de respuesta</summary>
El siguiente ejemplo muestra una respuesta del proveedor de billetera del remitente.
```json wrap
{
  "access_token": {
    "value": "...", // final access token required before creating outgoing payments
    "manage": "https://auth.cloudninebank.example.com/token/{...}", // management uri for access token
    "access": [
      {
        "type": "outgoing-payment",
        "actions": ["create"],
        "identifier": "https://cloudninebank.example.com/sender",
        "limits": {
          "receiver": "https://happylifebank.example.com/incoming-payments/{...}" // url of the incoming payment that's being paid
        }
      }
    ]
  },
  "continue": {
    "access_token": {
      "value": "..." // access token for continuing the request
    },
  "uri": "https://auth.cloudninebank.example.com/continue/{...}" // continuation request uri
  }
}
```
</details>

### 10. Solicitar la creación de un recurso de pago saliente

Utilice el token de acceso devuelto en el paso 9 para llamar a la <Badge text="POST" variant="success" /> [Create Outgoing Payment API](/apis/resource-server/operations/create-outgoing-payment/). Incluya el `quoteId` en la solicitud. La `quoteId` es la `id` devuelta en la respuesta de API Crear cotización (paso 5).

<Tabs syncKey="lang">
  <TabItem label='TypeScript/JavaScript' icon='seti:javascript'>
  ```ts wrap
  const senderOutgoingPayment = await client.outgoingPayment.create(
    {
      url: senderWalletAddress.resourceServer,
      accessToken: senderOutgoingPaymentGrant.access_token.value
    },
    {
      walletAddress: senderWalletAddress.id,
      quoteId: senderQuote.id
    }
  )
  ```
  </TabItem>
  <TabItem label='Rust' icon='seti:rust'>
  ```rust wrap
  use open_payments::types::OutgoingPaymentRequest;
  let outgoing_request = OutgoingPaymentRequest {
    wallet_address: sender_wallet_address.id.clone(),
    receiver: Some(recipient_incoming_payment.id.clone()),
    debit_amount: None,
    receive_amount: None,
    quote_id: Some(sender_quote.id.clone()),
  };
  let sender_outgoing_payment = client
    .outgoing_payments()
    .create(
      &sender_wallet_address.resource_server,
      &outgoing_request,
      Some(&sender_outgoing_payment_grant.access_token.value),
    )
    .await?;
  ```
  </TabItem>

  <TabItem label='PHP' icon='seti:php'>

```php wrap
$senderOutgoingPayment = $client->outgoingPayment()->create(
  [
    'url' => $senderWalletAddress->resourceServer,
    'accessToken' => $senderOutgoingPaymentGrant->access_token->value
  ],
  [
    'walletAddress' => $senderWalletAddress->id,
    'quoteId' => $senderQuote->id
  ]
);
```

  </TabItem>

  <TabItem label='Go' icon='seti:go'>

```go wrap
var outgoingPayload rs.CreateOutgoingPaymentRequest
if err := outgoingPayload.FromCreateOutgoingPaymentWithQuote(rs.CreateOutgoingPaymentWithQuote{
  WalletAddressSchema: *senderWalletAddress.Id,
  QuoteId:             *senderQuote.Id,
}); err != nil {
  log.Fatalf("Error creating payload: %v\n", err)
}

senderOutgoingPayment, err := client.OutgoingPayment.Create(context.TODO(), op.OutgoingPaymentCreateParams{
  BaseURL: *senderWalletAddress.ResourceServer,
  AccessToken: senderOutgoingPaymentGrant.AccessToken.Value,
  Payload: outgoingPayload,
})
if err != nil {
  log.Fatalf("Error creating outgoing payment: %v\n", err)
}
```

  </TabItem>
</Tabs>

Si la solicitud falla porque la cotización expiró, [solicite una nueva](#5-solicitar-la-creación-de-un-recurso-de-cotización) e intente otra vez. Si falla porque el token de acceso de la concesión de autorización ha expirado, llame a <Badge text="POST" variant="success" /> [Rotate Access Token API](/apis/auth-server/operations/post-token/) para obtener un nuevo token de acceso y, luego, vuelva a probar la solicitud con el nuevo token.

<details>
<summary>Ejemplo de respuesta</summary>
El siguiente ejemplo muestra una respuesta del proveedor de billetera del remitente.
```json wrap
{
  "id": "https://cloudninebank.example.com/outgoing-payments/{...}", // url identifying the outgoing payment
  "walletAddress": "https://cloudninebank.example.com/sender",
  "receiver": "https://happylifebank.example.com/incoming-payments/{...}", // url of the incoming payment being paid
  "debitAmount": {
    "value": "27778", // Sender pays $277.78 USD after currency conversion
    "assetCode": "USD",
    "assetScale": 2
  },
  "receiveAmount": {
    "value": "500000", // Recipient receives $5,000 MXN
    "assetCode": "MXN",
    "assetScale": 2
  },
  "sentAmount": {
    "value": "0",
    "assetCode": "USD",
    "assetScale": 2
  },
  "createdAt": "2025-03-12T23:20:54.52Z"
}
```
</details>
````

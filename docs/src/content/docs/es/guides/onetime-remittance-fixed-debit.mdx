---
title: Enviar una remesa con un monto de débito fijo.
---

import { LinkOut } from '@interledger/docs-design-system'
import { Tabs, TabItem, Badge } from '@astrojs/starlight/components'
import StartInteraction from '/src/partials/es/grant-start-interaction.mdx'
import FinishInteraction from '/src/partials/es/grant-finish-interaction.mdx'

:::tip[Resumen]
Aprenda cómo enviar un pago de remesa único al debitar la cuenta del remitente por un monto específico.
:::

Un pago de remesa es una transferencia de dinero de una persona a otra, normalmente entre países o a larga distancia, que a menudo implica una conversión de monedas. En esta guía, aprenderá cómo implementar una funcionalidad de pago único de remesa en la que sus usuarios puedan especificar exactamente cuánto quieren enviar, en lugar de cuánto debe recibir el destinatario.

Este enfoque es útil en particular para situaciones de aplicaciones de remesas en estos casos:

- Sus usuarios quieren pagar un monto fijo desde su cuenta.
- El destinatario recibe el monto que resulte después de la conversión de monedas.
- Sus usuarios quieren evitar la complejidad de calcular las tarifas de conversión por adelantado.

### Caso hipotético

Imagine que alguien en EE. UU. envía dinero a un familiar en México. Esta persona quiere enviar exactamente 100 dólares estadounidenses (USD) desde su cuenta, independientemente de cuánto reciba realmente su familiar después de que se apliquen los tipos de cambio. Esto difiere de los casos en los que el remitente especifica exactamente cuánto debe recibir el destinatario.

Para esta guía, asumirá el papel de un desarrollador que está creando una aplicación de remesas. La guía explica cómo enviar un pago de \$100 USD, en el que el remitente paga exactamente \$100, y el destinatario recibe el monto en pesos mexicanos (MXN) después de la conversión de monedas.

**Detalles de la transacción de ejemplo:**

- **El remitente paga**: $100.00 USD (monto exacto)
- **Conversión de moneda**: USD a MXN a un tipo de cambio de 17.00
- **El destinatario recibe**: \$1,700 MXN ($100 × 17.00)

Las tres partes que intervienen en este caso son las siguientes:

- **Desarrollador**: usted, la persona que construye la aplicación de remesas.
- **Remitente**: la persona que utiliza su aplicación para enviar dinero en USD.
- **Destinatario**: la persona que recibe el dinero en MXN.

Recuerde que Open Payments no ejecuta pagos ni toca dinero de ninguna manera. Se usa para emitir instrucciones de pago antes de que se produzca cualquier movimiento de dinero. Un ejemplo de una instrucción de pago es: "debitar exactamente \$100 de la cuenta del remitente y enviar el monto a la cuenta del destinatario después de que se apliquen los tipos de cambio".

## Puntos finales

- <Badge text="GET" variant="note" />
  <LinkOut href="https://openpayments.dev/apis/wallet-address-server/operations/get-wallet-address/">
    Get Wallet Address
  </LinkOut>
- <Badge text="POST" variant="success" />
  <LinkOut href="https://openpayments.dev/apis/auth-server/operations/post-request/">
    Grant Request
  </LinkOut>
- <Badge text="POST" variant="success" />
  <LinkOut href="https://openpayments.dev/apis/resource-server/operations/create-incoming-payment/">
    Create Incoming Payment
  </LinkOut>
- <Badge text="POST" variant="success" />
  <LinkOut href="https://openpayments.dev/apis/resource-server/operations/create-quote/">
    Create a Quote
  </LinkOut>
- <Badge text="POST" variant="success" />
  <LinkOut href="https://openpayments.dev/apis/resource-server/operations/create-outgoing-payment/">
    Create an Outgoing Payment
  </LinkOut>

## Pasos

### 1. Obtener los datos de la dirección de billetera

Cuando el remitente inicia un pago a través de su aplicación de remesas, usted necesita obtener la información de la dirección de billetera tanto del remitente como del destinatario.

Asumamos que el remitente ya ha proporcionado su propia dirección de billetera cuando se registró para usar su aplicación. Asumamos también que el remitente ingresó la dirección de billetera del destinatario en el formulario de pago de su aplicación al iniciar el pago.

Llame a la <Badge text="GET" variant="note" /> [Get Wallet Address API](/apis/wallet-address-server/operations/get-wallet-address) para cada dirección.

<Tabs syncKey="lang">
<TabItem label='TypeScript/JavaScript' icon='seti:javascript'>
  ```ts
  const senderWalletAddress = await client.walletAddress.get({
    url: 'https://cloudninebank.example.com/sender'
  })
  const recipientWalletAddress = await client.walletAddress.get({
    url: 'https://happylifebank.example.com/recipient'
  })
```
 </TabItem>
 <TabItem label='Rust' icon='seti:rust'>
 ```rust wrap
 let sender_wallet_address = client.wallet_address().get("https://cloudninebank.example.com/sender").await?;
 let recipient_wallet_address = client.wallet_address().get("https://happylifebank.example.com/recipient").await?;
 ```
 </TabItem>

<TabItem label="PHP" icon='seti:php'>
  ```php wrap
  $senderWalletAddress = $client->walletAddress()->get([
    'url' => 'https://cloudninebank.example.com/sender'
  ]);
  $recipientWalletAddress = $client->walletAddress()->get([
    'url' => 'https://happylifebank.example.com/recipient'
  ]);
  ```
</TabItem>

 <TabItem label='Go' icon='seti:go'>

```go wrap
senderWalletAddress, err := client.WalletAddress.Get(context.TODO(), op.WalletAddressGetParams{
  URL: "https://cloudninebank.example.com/sender",
})
if err != nil {
  log.Fatalf("Error fetching sender wallet address: %v\n", err)
}

recipientWalletAddress, err := client.WalletAddress.Get(context.TODO(), op.WalletAddressGetParams{
  URL: "https://happylifebank.example.com/recipient",
})
if err != nil {
  log.Fatalf("Error fetching recipient wallet address: %v\n", err)
}
```

 </TabItem>
</Tabs>
<details>
<summary>Respuestas de ejemplo</summary>
El siguiente ejemplo muestra una respuesta del proveedor de billetera del remitente.
```json wrap
{
  "id": "https://cloudninebank.example.com/sender",
  "assetCode": "USD",
  "assetScale": 2,
  "authServer": "https://auth.cloudninebank.example.com/",
  "resourceServer": "https://cloudninebank.example.com/op"
}
```
El siguiente ejemplo muestra una respuesta del proveedor de billetera del destinatario.

```json wrap
{
  "id": "https://happylifebank.example.com/recipient",
  "assetCode": "MXN",
  "assetScale": 2,
  "authServer": "https://auth.happylifebank.example.com/",
  "resourceServer": "https://happylifebank.example.com/op"
}
```

</details>

### 2. Solicitar una concesión de autorización para un pago entrante

Utilice los datos del destinatario `authServer`, recibidos en el paso anterior, para llamar a la <Badge text="POST" variant="success" /> [Grant Request API](/apis/auth-server/operations/post-request).

Esta llamada obtiene un token de acceso que permite a su aplicación solicitar la creación de un recurso de pago entrante en la cuenta de billetera del destinatario.

<Tabs syncKey="lang">
<TabItem label='TypeScript/JavaScript' icon='seti:javascript'>
  ```ts wrap
  const recipientIncomingPaymentGrant = await client.grant.request(
    {
      url: recipientWalletAddress.authServer
    },
    {
      access_token: {
        access: [
          {
            type: "incoming-payment",
            actions: ["create"],
          },
        ],
      },
    },
  );
````
 </TabItem>
 <TabItem label='Rust' icon='seti:rust'>
 ```rust wrap
 use open_payments::types::{AccessTokenRequest, AccessItem, IncomingPaymentAction, GrantRequest};
 let incoming_access = AccessTokenRequest {
   access: vec![AccessItem::IncomingPayment { actions: vec![IncomingPaymentAction::Create, IncomingPaymentAction::Complete], identifier: None }],
 };
 let incoming_grant_request = GrantRequest::new(incoming_access, None);
 let recipient_incoming_payment_grant = client
   .grant()
   .request(&recipient_wallet_address.auth_server, &incoming_grant_request)
   .await?;
 ```
 </TabItem>

 <TabItem label="PHP" icon='seti:php'>
 ```php wrap
  $recipientIncomingPaymentGrant = $client->grant()->request([
    'url' => $recipientWalletAddress->authServer
  ], [
    'access_token' => [
      'access' => [
        [
          'type' => 'incoming-payment',
          'actions' => ['create']
        ]
      ]
    ]
  ]);
 ```
 </TabItem>

 <TabItem label='Go' icon='seti:go'>

```go wrap
incomingAccess := as.AccessIncoming{
 	Type:    as.IncomingPayment,
 	Actions: []as.AccessIncomingActions{as.AccessIncomingActionsCreate},
}
accessItem := as.AccessItem{}
if err := accessItem.FromAccessIncoming(incomingAccess); err != nil {
 	log.Fatalf("Error creating AccessItem: %v\n", err)
}
accessToken := struct {
 	Access as.Access `json:"access"`
}{
 	Access: []as.AccessItem{accessItem},
}

recipientIncomingPaymentGrant, err := client.Grant.Request(context.TODO(), op.GrantRequestParams{
  URL: *recipientWalletAddress.AuthServer,
  RequestBody: as.GrantRequestWithAccessToken{AccessToken: accessToken},
})
if err != nil {
  log.Fatalf("Error requesting incoming payment grant: %v\n", err)
}

```

</TabItem>
</Tabs>
<details>
<summary>Ejemplo de respuesta</summary>
El siguiente ejemplo muestra una respuesta del proveedor de billetera del destinatario.

```json wrap
{
  "access_token": {
    "value": "...", // access token value for incoming payment grant
    "manage": "https://auth.happylifebank.example.com/token/{...}", // management uri for access token
    "access": [
      {
        "type": "incoming-payment",
        "actions": ["create"]
      }
    ]
  },
  "continue": {
    "access_token": {
      "value": "..." // access token for continuing the request
    },
    "uri": "https://auth.happylifebank.example.com/continue/{...}" // continuation request uri
  }
}
```

</details>

### 3. Solicitar la creación de un recurso de pago entrante

Use el token de acceso devuelto en la respuesta anterior para llamar a la <Badge text="POST" variant="success" /> [Create Incoming Payment API](/apis/resource-server/operations/create-incoming-payment).

Esta llamada solicita la creación de un recurso de pago entrante en la cuenta de billetera del destinatario.

<Tabs syncKey="lang">
  <TabItem label='TypeScript/JavaScript' icon='seti:javascript'>
  ```ts wrap
  const recipientIncomingPayment = await client.incomingPayment.create(
    {
      url: recipientWalletAddress.resourceServer,
      accessToken: recipientIncomingPaymentGrant.access_token.value
    },
    {
      walletAddress: recipientWalletAddress.id
    },
  )
```
 </TabItem>
 <TabItem label='Rust' icon='seti:rust'>
 ```rust wrap
 use open_payments::types::IncomingPaymentRequest;
 let incoming_request = IncomingPaymentRequest {
   wallet_address: recipient_wallet_address.id.clone(),
   incoming_amount: None,
   expires_at: None,
   metadata: None,
 };
 let recipient_incoming_payment = client
   .incoming_payments()
   .create(
     &recipient_wallet_address.resource_server,
     &incoming_request,
     Some(&recipient_incoming_payment_grant.access_token.value),
   )
   .await?;
 ```
 </TabItem>

  <TabItem label="PHP" icon='seti:php'>
  ```php wrap
    $recipientIncomingPayment = $client->incomingPayment()->create([
      'url' => $recipientWalletAddress->resourceServer,
      'accessToken' => $recipientIncomingPaymentGrant->access_token->value
    ], [
      'walletAddress' => $recipientWalletAddress->id
    ]);
  ```
  </TabItem>

 <TabItem label='Go' icon='seti:go'>

```go wrap
recipientIncomingPayment, err := client.IncomingPayment.Create(context.TODO(), op.IncomingPaymentCreateParams{
 	BaseURL:     *recipientWalletAddress.ResourceServer,
 	AccessToken: recipientIncomingPaymentGrant.AccessToken.Value,
 	Payload: rs.CreateIncomingPaymentJSONBody{
  	WalletAddressSchema: *recipientWalletAddress.Id,
  },
})
if err != nil {
 	log.Fatalf("Error creating incoming payment: %v\n", err)
}
```

 </TabItem>
</Tabs>
<details>
<summary>Ejemplo de respuesta</summary>
El siguiente ejemplo muestra una respuesta del proveedor de billetera del destinatario.

```json wrap
{
  "id": "https://happylifebank.example.com/incoming-payments/{...}",
  "walletAddress": "https://happylifebank.example.com/recipient",
  "receivedAmount": {
    "value": "0",
    "assetCode": "USD",
    "assetScale": 2
  },
  "completed": false,
  "createdAt": "2025-03-12T23:20:50.52Z",
  "methods": [
    {
      "type": "ilp",
      "ilpAddress": "...",
      "sharedSecret": "..."
    }
  ]
}
```

</details>

### 4. Solicitar una concesión de autorización para una cotización

Utilice los datos del remitente `authServer` recibidos en el paso 1 para llamar a la <Badge text="POST" variant="success" /> [Grant Request API](/apis/auth-server/operations/post-request).

Esta llamada obtiene un token de acceso que permite a su aplicación solicitar la creación de un recurso de cotización en la cuenta de billetera del remitente.

<Tabs syncKey="lang">
  <TabItem label='TypeScript/JavaScript' icon='seti:javascript'>
    ```ts wrap
    const senderQuoteGrant = await client.grant.request(
      {
        url: senderWalletAddress.authServer
      },
      {
        access_token: {
          access: [
            {
              type: 'quote',
              actions: ['create']
            }
          ]
        }
      }
    )
    ```
  </TabItem>
  <TabItem label='Rust' icon='seti:rust'>
 
 ```rust wrap
 use open_payments::types::{AccessTokenRequest, AccessItem, QuoteAction, GrantRequest};
 let quote_access = AccessTokenRequest {
   access: vec![AccessItem::Quote { actions: vec![QuoteAction::Create] }],
 };
 let quote_grant_request = GrantRequest::new(quote_access, None);
 let sender_quote_grant = client
   .grant()
   .request(&sender_wallet_address.auth_server, &quote_grant_request)
   .await?;
 ```
 </TabItem>

  <TabItem label="PHP" icon='seti:php'>
  ```php wrap
  $senderQuoteGrant = $client->grant()->request(
    [
      'url' => $senderWalletAddress->authServer
    ],
    [
      'access_token' => [
        'access' => [
          [
            'type' => 'quote',
            'actions' => ['create']
          ]
        ]
      ]
    ]);
  ```
  </TabItem>

 <TabItem label='Go' icon='seti:go'>

```go wrap
quoteAccess := as.AccessQuote{
  Type:    as.Quote,
 	Actions: []as.AccessQuoteActions{as.Create},
}
quoteAccessItem := as.AccessItem{}
if err := quoteAccessItem.FromAccessQuote(quoteAccess); err != nil {
 	log.Fatalf("Error creating AccessItem: %v\n", err)
}
quoteAccessToken := struct {
 	Access as.Access `json:"access"`
}{
	Access: []as.AccessItem{quoteAccessItem},
}

senderQuoteGrant, err := client.Grant.Request(context.TODO(), op.GrantRequestParams{
  URL: senderWalletAddress.AuthServer,
  RequestBody: as.GrantRequestWithAccessToken{AccessToken: quoteAccessToken},
})
if err != nil {
  log.Fatalf("Error requesting quote grant: %v\n", err)
}

```

 </TabItem>
</Tabs>
<details>
<summary>Ejemplo de respuesta</summary>
```json wrap
{
  "access_token": {
    "value": "...", // access token value for quote grant
    "manage": "https://auth.cloudninebank.example.com/token/{...}", // management uri for access token
    "access": [
      {
        "type": "quote",
        "actions": ["create"]
      }
    ]
  },
  "continue": {
    "access_token": {
      "value": "..." // access token for continuing the request
    },
    "uri": "https://auth.cloudninebank.example.com/continue/{...}" // continuation request uri
  }
}
```
</details>

### 5. Solicitar la creación de un recurso de cotización

Utilice el token de acceso recibido en el paso anterior para llamar a la <Badge text="POST" variant="success" /> [Create Quote API](/apis/resource-server/operations/create-quote).

Esta llamada solicita la creación de un recurso de cotización en la cuenta de la billetera del remitente. La solicitud debe contener el `receiver`, que es la `id` del pago entrante del destinatario, junto con el `debitAmount`, que es el monto exacto que el remitente desea pagar.

El `debitAmount` especifica que el remitente pagará exactamente $100 USD, y el destinatario recibirá cualquier monto que quede después de la conversión de monedas.

<Tabs syncKey="lang">
<TabItem label='TypeScript/JavaScript' icon='seti:javascript'>
  ```ts wrap
  const senderQuote = await client.quote.create(
    {
      url: senderWalletAddress.resourceServer,
      accessToken: senderQuoteGrant.access_token.value
    },
    {
      method: 'ilp',
      walletAddress: senderWalletAddress.id,
      receiver: recipientIncomingPayment.id,
      debitAmount: {
        value: '10000', 
        assetCode: 'USD',
        assetScale: 2
      }
    }
  )
```
 </TabItem>
 <TabItem label='Rust' icon='seti:rust'>
 
 ```rust wrap
 use open_payments::types::{QuoteRequest, QuoteMethod, Amount};
 let quote_request = QuoteRequest {
   method: QuoteMethod::Ilp,
   wallet_address: Some(sender_wallet_address.id.clone()),
   receiver: Some(recipient_incoming_payment.id.clone()),
   debit_amount: Some(Amount {
     value: "10000".into(),
     asset_code: "USD".into(),
     asset_scale: 2,
   }),
   receive_amount: None,
 };
 let sender_quote = client
   .quotes()
   .create(
     &sender_wallet_address.resource_server,
     &quote_request,
     Some(&sender_quote_grant.access_token.value),
   )
   .await?;
 ```
 </TabItem>

<TabItem label="PHP" icon='seti:php'>
  ```php wrap
  $senderQuote = $client->quote()->create(
    [
      'url' => $senderWalletAddress->resourceServer,
      'accessToken' => $senderQuoteGrant->access_token->value
    ],
    [
      'method' => 'ilp',
      'walletAddress' => $senderWalletAddress->id,
      'receiver' => $recipientIncomingPayment->id,
      'debitAmount' => [
        'value' => '10000',
        'assetCode' => 'USD',
        'assetScale' => 2
      ]
    ]
  );
  ```
</TabItem>

 <TabItem label='Go' icon='seti:go'>

```go wrap
senderQuote, err := client.Quote.Create(context.TODO(), op.QuoteCreateParams{
 	BaseURL:     *senderWalletAddress.ResourceServer,
 	AccessToken: senderQuoteGrant.AccessToken.Value,
 	Payload: rs.CreateQuoteJSONBody1{
 		WalletAddressSchema: *senderWalletAddress.Id,
 		Receiver:            *recipientIncomingPayment.Id,
 		Method:              "ilp",
 		DebitAmount: rs.Amount{
 			Value:      "10000",
 			AssetCode:  "USD",
 			AssetScale: 2,
 		},
 	},
})
if err != nil {
 	log.Fatalf("Error creating quote: %v\n", err)
}
```

 </TabItem>
</Tabs>
La respuesta devuelve un `receiveAmount`, un `debitAmount` y demás información requerida.

- `debitAmount`: el monto que el remitente debe pagar (exactamente $100.00 USD en nuestro ejemplo).
- `receiveAmount`: el monto que el destinatario recibirá realmente ($1,700.00 MXN en nuestro ejemplo) después de la conversión de monedas.

:::note[Cotizaciones con vencimiento]
Las cotizaciones incluyen una marca de tiempo `expiresAt`. Cree el pago saliente antes de que la cotización expire. Si la creación falla porque la cotización expiró, solicite una nueva e intente otra vez.
:::

<details>
<summary>Ejemplo de respuesta</summary>
El siguiente ejemplo muestra una respuesta del proveedor de billetera del remitente.

```json wrap
{
  "id": "https://cloudninebank.example.com/quotes/{...}", // url identifying the quote
  "walletAddress": "https://cloudninebank.example.com/sender",
  "receiver": "https://happylifebank.example.com/incoming-payments/{...}", // url of the incoming payment the quote is created for
  "debitAmount": {
    "value": "10000", // Sender pays exactly $100.00 USD
    "assetCode": "USD",
    "assetScale": 2
  },
  "receiveAmount": {
    "value": "170000", // Recipient receives $1,700.00 MXN  after currency conversion
    "assetCode": "MXN",
    "assetScale": 2
  },
  "method": "ilp",
  "createdAt": "2025-03-12T23:22:51.50Z",
  "expiresAt": "2025-03-12T23:24:51.50Z"
}
```

</details>

### 6. Solicitar una concesión de autorización interactiva para un pago saliente

Utilice la información del remitente `authServer` recibida en el paso 1 para llamar a la <Badge text="POST" variant="success" /> [Grant Request API](/apis/auth-server/operations/post-request).

Esta llamada obtiene un token de acceso que permite a su aplicación solicitar la creación de un recurso de pago saliente en la cuenta de billetera del remitente.

:::note
Los pagos salientes requieren una concesión de autorización interactiva. Este tipo de concesión de autorización obtendrá el consentimiento del remitente antes de que se realice un pago saliente desde su cuenta de billetera. Puede encontrar más información en las páginas del [flujo de Open Payments](/concepts/op-flow/#outgoing-payment) y [proveedores de identidad](/identity/idp).
:::

<Tabs syncKey="lang">
<TabItem label='TypeScript/JavaScript' icon='seti:javascript'>
  ```ts wrap
  const pendingSenderOutgoingPaymentGrant = await client.grant.request(
    {
      url: senderWalletAddress.authServer
    },
    {
      access_token: {
        access: [
          {
            identifier: senderWalletAddress.id,
            type: 'outgoing-payment',
            actions: ['create'],
            limits: {
              debitAmount: {
                assetCode: 'USD',
                assetScale: 2,
                value: '10000', 
              }
            }
          }
        ]
      },
      interact: {
        start: ['redirect'],
        finish: {
          method: 'redirect',
          uri: 'https://myapp.example.com/finish/{...}', // where to redirect your user after they've completed the interaction
          nonce: NONCE
        }
      }
    }
  )
  ```
 </TabItem>
 <TabItem label='Rust' icon='seti:rust'>
 ```rust wrap
 use open_payments::types::{
   AccessTokenRequest,
   AccessItem,
   OutgoingPaymentAction,
   AccessLimits,
   Amount,
   InteractRequest,
   InteractStart,
   InteractFinish,
   InteractFinishMethod,
   GrantRequest,
 };

let outgoing_access = AccessTokenRequest {
access: vec![AccessItem::OutgoingPayment {
identifier: Some(sender_wallet_address.id.clone()),
actions: vec![OutgoingPaymentAction::Create],
limits: Some(AccessLimits {
debit_amount: Some(Amount {
value: "10000".into(),
asset_code: "USD".into(),
asset_scale: 2,
}),
..Default::default()
}),
}],
};

let interact = InteractRequest {
start: Some(vec![InteractStart::Redirect]),
finish: Some(InteractFinish {
method: InteractFinishMethod::Redirect,
uri: Some("https://myapp.example.com/finish/{...}".into()),
nonce: Some("NONCE".into()),
}),
};

let outgoing_grant_request = GrantRequest::new(outgoing_access, Some(interact));

let pending_sender_outgoing_payment_grant = client
.grant()
.request(&sender_wallet_address.auth_server, &outgoing_grant_request)
.await?;

````

</TabItem>

<TabItem label="PHP" icon='seti:php'>
  ```php wrap
    $pendingSenderOutgoingPaymentGrant = $client->grant()->request(
      [
        'url' => $senderWalletAddress->authServer
      ],
      [
        'access_token' => [
          'access' => [
            [
              'identifier' => $senderWalletAddress->id,
              'type' => 'outgoing-payment',
              'actions' => ['create'],
              'limits' => [
                'debitAmount' => [
                  'assetCode' => 'USD',
                  'assetScale' => 2,
                  'value' => '10000'
                ]
              ]
            ]
          ]
        ],
        'interact' => [
          'start' => ['redirect'],
          'finish' => [
            'method' => 'redirect',
            'uri' => 'https://myapp.example.com/finish/{...}', // where to redirect your user after they've completed the interaction
            'nonce' => 'NONCE'
          ]
        ]
      ]
    );
  ```
  </TabItem>

<TabItem label='Go' icon='seti:go'>

```go wrap
outgoingAccess := as.AccessOutgoing{
	Type:       as.OutgoingPayment,
	Actions:    []as.AccessOutgoingActions{as.AccessOutgoingActionsCreate},
	Identifier: *senderWalletAddress.Id,
	Limits: &as.LimitsOutgoing{
		DebitAmount: &as.Amount{
			Value:      "10000",
			AssetCode:  "USD",
			AssetScale: 2,
		},
	},
}
outgoingAccessItem := as.AccessItem{}
if err := outgoingAccessItem.FromAccessOutgoing(outgoingAccess); err != nil {
	log.Fatalf("Error creating AccessItem: %v\n", err)
}
outgoingAccessToken := struct {
	Access as.Access `json:"access"`
}{
	Access: []as.AccessItem{outgoingAccessItem},
}
interact := &as.InteractRequest{
	Start: []as.InteractRequestStart{as.InteractRequestStartRedirect},
	Finish: &as.InteractRequestFinish{
		Method: as.Redirect,
		Uri:    "https://myapp.example.com/finish/{...}",
		Nonce:  NONCE,
	},
}

pendingSenderOutgoingPaymentGrant, err := client.Grant.Request(context.TODO(), op.GrantRequestParams{
	URL: *senderWalletAddress.AuthServer,
	RequestBody: as.GrantRequestWithAccessToken{
		AccessToken: outgoingAccessToken,
		Interact:    interact,
	},
})
if err != nil {
	log.Fatalf("Error requesting outgoing payment grant: %v\n", err)
}
````

</TabItem>
</Tabs>
<details>
<summary>Ejemplo de respuesta</summary>
```json wrap
{
  "interact": {
    "redirect": "https://auth.cloudninebank.example.com/{...}", // uri to redirect the sender to, to begin interaction
    "finish": "..." // unique key to secure the callback
  },
  "continue": {
    "access_token": {
      "value": "..." // access token for continuing the outgoing payment grant request
    },
    "uri": "https://auth.cloudninebank.example.com/continue/{...}", // uri for continuing the outgoing payment grant request
    "wait": 30
  }
}
```
</details>

### 7. Comenzar la interacción con el usuario

<StartInteraction />

### 8. Finalizar la interacción con el usuario

<FinishInteraction />

### 9. Solicitar una continuación de la concesión de autorización

En nuestro ejemplo, suponemos que el IdP con el que interactuó su usuario cuenta con una interfaz de usuario. Cuando la interacción finaliza, el usuario regresa a su aplicación. Ahora su aplicación puede realizar una solicitud de continuación de la concesión de autorización de pago saliente.

:::note
En una situación hipotética donde una interfaz de usuario no se encuentra disponible, analice la posibilidad de implementar un mecanismo de sondeo para verificar que se haya completado la interacción.
:::

Llame a la <Badge text="POST" variant="success" /> [Grant Continuation Request API](/apis/auth-server/operations/post-continue). Esta llamada solicita un token de acceso que permite a su aplicación solicitar la creación de un recurso de pago saliente en la cuenta de billetera del remitente.

Emita la solicitud al `continue.uri` proporcionado en la respuesta de concesión de autorización de pago saliente inicial (paso 6).

Incluya la `interact_ref` devuelta en los parámetros de consulta del URI de redirección.

<Tabs syncKey="lang">
  <TabItem label='TypeScript/JavaScript' icon='seti:javascript'>
    ```ts wrap
    const senderOutgoingPaymentGrant = await client.grant.continue(
      {
        url: pendingSenderOutgoingPaymentGrant.continue.uri,
        accessToken: pendingSenderOutgoingPaymentGrant.continue.access_token.value
      },
      {
        interact_ref: interactRef
      }
    )
    ```
 </TabItem>
 <TabItem label='Rust' icon='seti:rust'>
 ```rust wrap
 let continue_field = match &pending_sender_outgoing_payment_grant.continue_field {
   Some(c) => c,
   None => {
     eprintln!("Missing continue field on pending grant");
     return Ok(());
   }
 };
 let sender_outgoing_payment_grant = client
   .grant()
   .continue_grant(
     &continue_field.uri,
     &interact_ref,
     Some(&continue_field.access_token.value),
   )
   .await?;
 ```
 </TabItem>

  <TabItem label="PHP" icon='seti:php'>
  ```php wrap
    $senderOutgoingPaymentGrant = $client->grant()->continue(
      [
        'url' => $pendingSenderOutgoingPaymentGrant->continue->uri,
        'accessToken' => $pendingSenderOutgoingPaymentGrant->continue->access_token->value
      ],
      [
        'interact_ref' => $interactRef
      ]
    );
  ```
  </TabItem>

 <TabItem label='Go' icon='seti:go'>

```go wrap
senderOutgoingPaymentGrant, err := client.Grant.Continue(context.TODO(), op.GrantContinueParams{
  URL:         pendingSenderOutgoingPaymentGrant.Continue.Uri,
  AccessToken: pendingSenderOutgoingPaymentGrant.Continue.AccessToken.Value,
  InteractRef: INTERACT_REF,
})
if err != nil {
 	log.Fatalf("Error continuing grant: %v\n", err)
}
```

 </TabItem>
</Tabs>
<details>
<summary>Ejemplo de respuesta</summary>
```json wrap
{
  "access_token": {
    "value": "...", // final access token required before creating outgoing payments
    "manage": "https://auth.cloudninebank.example.com/token/{...}", // management uri for access token
    "access": [
      {
        "type": "outgoing-payment",
        "actions": ["create", "read"],
        "identifier": "https://cloudninebank.example.com/sender",
        "limits": {
          "receiver": "https://happylifebank.example.com/incoming-payments/{...}" // url of the incoming payment that's being paid
        }
      }
    ]
  },
  "continue": {
    "access_token": {
      "value": "..." // access token for continuing the request
    },
    "uri": "https://auth.cloudninebank.example.com/continue/{...}" // continuation request uri
  }
}
```
</details>

### 10. Solicitar la creación de un recurso de pago saliente

Utilice el token de acceso devuelto en el paso 9 para llamar a la <Badge text="POST" variant="success" /> [Create Outgoing Payment API](/apis/resource-server/operations/create-outgoing-payment/). Incluya el `quoteId` en la solicitud. La `quoteId` es la `id` devuelta en la respuesta de Create Quote API (paso 5).

<Tabs syncKey="lang">
<TabItem label='TypeScript/JavaScript' icon='seti:javascript'>
  ```ts wrap
  const senderOutgoingPayment = await client.outgoingPayment.create(
    {
      url: senderWalletAddress.resourceServer,
      accessToken: senderOutgoingPaymentGrant.access_token.value
    },
    {
      walletAddress: senderWalletAddress.id,
      quoteId: senderQuote.id
    }
  )
```
</TabItem>
<TabItem label='Rust' icon='seti:rust'>
 ```rust wrap
 use open_payments::types::OutgoingPaymentRequest;
 let outgoing_request = OutgoingPaymentRequest {
   wallet_address: sender_wallet_address.id.clone(),
   receiver: Some(recipient_incoming_payment.id.clone()),
   debit_amount: None,
   receive_amount: None,
   quote_id: Some(sender_quote.id.clone()),
 };
 let sender_outgoing_payment = client
   .outgoing_payments()
   .create(
     &sender_wallet_address.resource_server,
     &outgoing_request,
     Some(&sender_outgoing_payment_grant.access_token.value),
   )
   .await?;
 ```
 </TabItem>

 <TabItem label="PHP" icon='seti:php'>
  ```php wrap
    $senderOutgoingPayment = $client->outgoingPayment()->create(
      [
        'url' => $senderWalletAddress->resourceServer,
        'accessToken' => $senderOutgoingPaymentGrant->access_token->value
      ],
      [
        'walletAddress' => $senderWalletAddress->id,
        'quoteId' => $senderQuote->id
      ]
    );
  ```
  </TabItem>

 <TabItem label='Go' icon='seti:go'>

```go wrap
var outgoingPayload rs.CreateOutgoingPaymentRequest
if err := outgoingPayload.FromCreateOutgoingPaymentWithQuote(rs.CreateOutgoingPaymentWithQuote{
 	WalletAddressSchema: *senderWalletAddress.Id,
 	QuoteId:             *senderQuote.Id,
}); err != nil {
 	log.Fatalf("Error creating payload: %v\n", err)
}

senderOutgoingPayment, err := client.OutgoingPayment.Create(context.TODO(), op.OutgoingPaymentCreateParams{
  BaseURL: senderWalletAddress.ResourceServer,
  AccessToken: senderOutgoingPaymentGrant.AccessToken.Value,
  Payload: outgoingPayload,
})
if err != nil {
  log.Fatalf("Error creating outgoing payment: %v\n", err)
}

```

 </TabItem>
</Tabs>
<details>
<summary>Ejemplo de respuesta</summary>
El siguiente ejemplo muestra una respuesta cuando se crea un recurso de pago saliente en la cuenta del remitente.

```json wrap
{
  "id": "https://cloudninebank.example.com/outgoing-payments/{...}", // url identifying the outgoing payment
  "walletAddress": "https://cloudninebank.example.com/sender",
  "receiver": "https://happylifebank.example.com/incoming-payments/{...}", // url of the incoming payment being paid
  "debitAmount": {
    "value": "10000", // Sender pays exactly $100.00 USD
    "assetCode": "USD",
    "assetScale": 2
  },
  "receiveAmount": {
    "value": "170000", // Recipient receives $1,700.00 MXN after currency conversion
    "assetCode": "MXN",
    "assetScale": 2
  },
  "sentAmount": {
    "value": "0",
    "assetCode": "USD",
    "assetScale": 2
  },
  "createdAt": "2022-03-12T23:20:54.52Z"
}
```

</details>
